package org.apache.sysds.runtime.matrix.data;

import java.util.Arrays;

public class LibMatrixFourier2 {

    /**
     * Function to perform Fast Fourier Transformation on a given array.
     *
     * @param in array of ComplexDoubles
     * @return array of ComplexDoubles
     */
    public static ComplexDouble[] fft(double[] in) {
        boolean wasPadded = false;
        int originalLength = in.length;

        ComplexDouble[] complex = new ComplexDouble[in.length];
        for(int i=0; i<in.length; i++){
            complex[i] = new ComplexDouble(in[i],0);
        }

        // Check if the length is a power of two
        if (Integer.bitCount(originalLength) != 1) {
            sub = fillToPowerOfTwo(complex); // Pad the array if not a power of two
            wasPadded = true;
        }


        // Perform FFT on the (possibly padded) array
        ComplexDouble[] result = fftRecursive(complex);

        // Trim the result if the array was padded
        if (wasPadded) {
            return Arrays.copyOf(result, originalLength);
        } else {
            return result;
        }
    }

    /**
     * Recursive helper method for FFT.
     *
     * @param in array of ComplexDoubles
     * @return array of ComplexDoubles
     */
    private static ComplexDouble[] fftRecursive(ComplexDouble[] in) {
        int n = in.length;
        if (n == 1) {
            return in;
        }

        double angle = 2 * Math.PI / n;
        ComplexDouble omega = new ComplexDouble(Math.cos(angle), Math.sin(angle));
        ComplexDouble[] even = new ComplexDouble[n / 2];
        ComplexDouble[] odd = new ComplexDouble[n / 2];

        for (int i = 0; i < n / 2; i++) {
            even[i] = in[i * 2];
            odd[i] = in[i * 2 + 1];
        }

        ComplexDouble[] resEven = fftRecursive(even);
        ComplexDouble[] resOdd = fftRecursive(odd);

        ComplexDouble[] res = new ComplexDouble[n];
        for (int j = 0; j < n / 2; j++) {
            ComplexDouble oddPart = omega.pow(j).mul(resOdd[j]);
            res[j] = resEven[j].add(oddPart);
            res[j + n / 2] = resEven[j].sub(oddPart);
        }

        return res;
    }


    /**
     * Function to fill a given array of ComplexDoubles with 0-ComplexDoubles,
     * so that the length is a power of two. Needed for FFT.
     *
     * @param in array of ComplexDoubles
     * @return array of ComplexDoubles
     */
    private static ComplexDouble[] fillToPowerOfTwo(ComplexDouble[] in) {
        int paddedLength = nextPowerOfTwo(in.length);
        ComplexDouble[] paddedIn = new ComplexDouble[paddedLength];
        System.arraycopy(in, 0, paddedIn, 0, in.length);
        for (int i = in.length; i < paddedLength; i++) {
            paddedIn[i] = new ComplexDouble(0, 0);
        }
        return paddedIn;
    }

    /**
     * Function for calculating the next larger int which is a power of two.
     *
     * @param n integer
     * @return next larger int which is a power of two
     */
    private static int nextPowerOfTwo(int n) {
        int res = 1;
        while (res < n) {
            res *= 2;
        }
        return res;
    }

    // Assuming the ComplexDouble class is defined elsewhere
}
