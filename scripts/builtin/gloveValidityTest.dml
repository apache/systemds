#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

cosine_similarity = function(matrix[double] trained_emb)
    return (matrix[double] cosine_sim){
    /*
     * Computes cosine similarity between word embeddings.
     *
     * Inputs:
     *  - trained_emb: Matrix of word embeddings of shape (N, D), where N is the number of words and D is the embedding dimension.
     *
     * Outputs:
     *  - cosine_sim: Matrix of cosine similarity scores between word embeddings, shape (N, N).
     */
    dot_product = trained_emb %*% t(trained_emb);
    row_norms = rowSums(trained_emb^2) ^ 0.5;
    denominator = row_norms %*% t(row_norms);
    cosine_sim = dot_product / denominator;
}

get_top = function(matrix[double] trained_emb, int k)
    return (matrix[double] topN_indices, matrix[double] topN_values){
    /*
     * Retrieves the top k most similar word vectors for each word.
     *
     * Inputs:
     *  - trained_emb: Matrix of word embeddings of shape (N, D).
     *  - k: Number of top similar words to retrieve.
     *
     * Outputs:
     *  - topN_indices: Matrix containing indices of the top k most similar words for each word, shape (N, k).
     *  - topN_values: Matrix containing similarity values of the top k most similar words for each word, shape (N, k).
     */
    S = cosine_similarity(trained_emb);
    n = nrow(S);
    I = diag(matrix(1, rows=nrow(S), cols=1));
    S = S * (1 - I) + (-1.0 * I);

    # Get the sorted indices (descending order) of each row
    topN_indices = matrix(0, rows=n, cols=k);
    topN_values = matrix(0, rows=n, cols=k);

    for (i in 1:n){
        Scol = S[,i];
        topN = order(target=Scol, by=1, decreasing=TRUE, index.return=TRUE);
        topNval = order(target=Scol, by=1, decreasing=TRUE, index.return=FALSE);

        topN = topN[1:k,];
        topv = topNval[1:k,];

        topN_indices[i,] = t(topN);
        topN_values[i,] = t(topv);
    }
}

accuracy = function(frame[unknown] X, frame[unknown] Y, int k)
    return (double acc){
    /*
     * Computes accuracy based on the overlap of the top-k nearest neighbors between two sets of word embeddings.
     *
     * Inputs:
     *  - X: First data frame containing a word column and embedding columns (shape: N x (D+1)).
     *  - Y: Second data frame containing a word column and embedding columns (shape: N x (D+1)).
     *
     * Outputs:
     *  - acc: Scalar value representing the accuracy as the fraction of words where the top-k nearest neighbors match between X and Y.
     */

    # Extract only the embedding values, excluding the word column
    X = as.matrix(X[,2:ncol(X)]);
    Y = as.matrix(Y[,2:ncol(Y)]);

    [A, Aval] = get_top(X, k);
    [B, Bval] = get_top(Y, k);

    count = 0;
    for (i in 1:nrow(A)){
        # Select a specific row from both matrices (change row indices as needed)
        row1 = A[i,];  # First row of A (1 x m)
        row2 = B[i,];  # First row of B (1 x n)

        # Expand both rows to create a pairwise comparison matrix
        row1_expanded = t(row1) %*% matrix(1, rows=1, cols=ncol(row2));  # (m x n)
        row2_expanded = matrix(1, rows=ncol(row1), cols=1) %*% row2;  # (m x n)

        # Element-wise comparison to find matches
        matches = (row1_expanded == row2_expanded);  # (m x n) Boolean matrix

        # Reduce to find unique elements that exist in both rows
        overlap_mask = rowSums(matches) > 0;  # (1 x m) mask of matched elements
        common_elements = row1 * t(overlap_mask);  # Retain only matching elements

        # Remove zeros (non-matching elements set to 0)
        filtered_common_elements = removeEmpty(target=common_elements, margin="cols");

        if (as.scalar(filtered_common_elements[1,1])!= 0){
          count = count+1;
        }
    }
    acc = count/nrow(A); #output
}

#X = read($1, format="csv", sep = " ", header=FALSE, data_type="frame");
#Y = read($2, format="csv", sep = " ", header=FALSE, data_type="frame");
#k = 10;
#accuracy(X,Y,k);
