#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# This script implements the hidden markov model method
# INPUT:
# --------------------------------------------------------------------------------------------
# X         Set of outputs
# OUTPUT:
# --------------------------------------------------------------------------------------------
# P     Probability of the set of outputs
# --------------------------------------------------------------------------------------------

m_hmm = function(Matrix[Double] X, String model="N") return (Matrix[Double] P, Matrix[Double] A, Matrix[Double] B) 
{
    """
    if(model != "N" & model != "S")
        # N is for number model and S for string model
        stop("model not supported, should be in S or N");

    if (model == "S")
    """

    # change later
    n_states = 5

    [P, A, B] = fit(X, n_states)
}

fit = function(Matrix[Double] X, Integer n_states) return (Matrix[Double] P, Matrix[Double] A, Matrix[Double] B) 
{
    # probability of the state at timestep 1
    init_prob = matrix(1/n_states, rows=1, cols=n_states)
    
    # probabilities of transition from one one state to another
    A = matrix(1/n_states, rows=n_states, cols=n_states)

    # probabilities of a state producing an output
    B = matrix(1/ncol(X), rows=n_states, cols=ncol(X))

    for (i in 1:20) {
        if (i == 1)
            init_prob = matrix(1/n_states, rows=1, cols=n_states)
            A = matrix(1/n_states, rows=n_states, cols=n_states)
            B = matrix(1/ncol(X), rows=n_states, cols=ncol(X))
            
        alpha = forward(init_prob, B, X)
        beta = backward(B, A, X)

        initial_prob, A, B = calc_init_prob(alpha, beta)
    }
}

forward = function(Matrix[Double] init_prob, Matrix[Double] B, Matrix[Double] X) return (Matrix[Double] alpha)
{
    alpha = rand(rows=nrow(A), cols = ncol(A))
}


backward = function(Matrix[Double] B, Matrix[Double] A, Matrix[Double] X) return (Matrix[Double] beta)
{   
    beta = rand(rows=nrow(A), cols=ncol(A))
}

calc_init_prob = function(Matrix[Double] alpha, Matrix[Double] beta) return (Matrix[Double] pie)
{
    pie = rand(rows=nrow(alpha), cols=ncol(beta))
}