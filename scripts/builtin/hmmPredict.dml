#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# This script implements the hidden markov model method
# INPUT:
# --------------------------------------------------------------------------------------------
# X         Set of outputs
# OUTPUT:
# --------------------------------------------------------------------------------------------
# P     Probability of the set of outputs
# --------------------------------------------------------------------------------------------

choose_value = function (matrix[double] prob_dist) return (double val)
{
    #useful for selecting output or states given probability distribution
    
    #choosing using cumulative distribution
    cum_prob = cumsum(prob_dist)
    
    R = rand(rows=1, cols=1, min=0, max=1)
    
    #adding 1 to colsum because indexing starts from 1
    val = as.scalar(colSums(cum_prob <= R) + 1)
}

get_all_states = function (matrix[double] A, matrix[double] ip, integer k) return (matrix[double] states)
{
    init_state = choose_value(ip)
    states = matrix(0, rows=k, cols=1)
    states[1, 1] = init_state
    s = init_state
    
    for (i in 2:k) {
        next_state = choose_value(t(A[s, ])) 
        states[i, 1] = next_state
        s = next_state
    }
}

get_outputs = function (matrix[double] B, matrix[double] states) return (matrix[double] outputs)
{
    outputs = matrix(0, rows=nrow(states), cols=1)
    for (i in 1:nrow(states)) {
        s = as.scalar(states[i, 1])
        outputs[i, 1] = choose_value(t(B[s, ]))
    }
}

m_hmmPredict = function(Matrix[Double] X, Integer k) return (Matrix[Double] outputs)
{
    /*
    A, B, ip = hmm(X)

    The above would be the function call to obtain model parameters. 
    Instead, the following has dummy model parameters to for the functions to work
    */

    n_states = 3
    n_outputs = 3
    
    A = matrix(1/n_states, rows=n_states, cols=n_states)
    B = matrix(1/n_outputs, rows=n_states, cols=n_outputs)
    ip = matrix(1/n_states, rows=n_states, cols=1)

    states = get_all_states(A, ip, k)
    outputs = get_outputs(B, states)
}    

