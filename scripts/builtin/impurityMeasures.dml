#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# This function computes the measure of impurity for the given dataset based on the passed method (gini or entropy).
# The current version expects the target vector to contain only 0 or 1 values.
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------------------------------------------------
# NAME                  TYPE               DEFAULT     MEANING
# ----------------------------------------------------------------------------------------------------------------------
# X                     Matrix[Double]      ---        Feature matrix.
# Y                     Matrix[Double]      ---        Target vector containing 0 and 1 values
# R                     Matrix[Double]      ---        Vector indicating whether a feature is categorical or continuous.
#                                                      1 denotes a continuous feature, larger values indicate the number
#                                                      of categories.
# method                String              ---        String indicating the method to use; either "entropy" or "gini".
# ----------------------------------------------------------------------------------------------------------------------

# Output(s)
# ----------------------------------------------------------------------------------------------------------------------
# NAME                  TYPE               DEFAULT     MEANING
# ----------------------------------------------------------------------------------------------------------------------
# IM                    Matrix[Double]      ---        (1 x ncol(X)) row vector containing information/gini gain for
#                                                      each feature of the dataset.
#                                                      In case of gini, the values denote the gini gains, i.e. how much
#                                                      impurity was "removed" with the respective split. The higher the
#                                                      value, the better the split.
#                                                      In case of entropy, the values denote the information gains, i.e.
#                                                      how much entropy was removed. The higher the information gain,
#                                                      the better the split.
# ----------------------------------------------------------------------------------------------------------------------

m_impurityMeasures = function(Matrix[Double] X, Matrix[Double] Y, Matrix[Double] R, String method)
  return (Matrix[Double] IM)
{
  if (method != "entropy" & method != "gini") {
    stop("Please specify the correct method - should be either entropy or gini.")
  }

  IM = matrix(0.0, rows = 1, cols = ncol(X))

  for (i in 1:ncol(X)) {
    if (as.scalar(R[,i]) == 1) {
      bins = 4 # todo: decide number of bins
      binning_feature = applyBinning(X[,i], bins)
      feature_measure = getMeasure(binning_feature, Y, bins, method)
      IM[,i] = feature_measure
    } else {
      max_cat = max(X[,i])
      feature_measure = getMeasure(X[,i], Y, max_cat, method)
      IM[,i] = feature_measure
    }
  }
}

getMeasure = function(Matrix[Double] feature, Matrix[Double] Y, Double max_cat, String method)
  return (Double gain)
{
  n_true_labels = sum(Y)
  n_false_labels = length(Y) - n_true_labels
  parent_impurity = calcImpurity(n_true_labels, n_false_labels, length(feature), method)

  # calculate the impurity after the split
  children_impurity = 0
  for (i in 1:max_cat) {
    count_true = 0
    count_false = 0
    for (j in 1:length(feature)) {
      if (as.scalar(feature[j,]) == i) {
        if (as.scalar(Y[j,]) == 0) {
          count_false += 1
        } else {
          count_true += 1
        }
      }
    }
    if (!(count_true == 0 & count_false == 0)) {
      children_impurity = children_impurity + calcImpurity(count_true, count_false, length(feature), method)
    }
  }
  gain = parent_impurity - children_impurity
}

calcImpurity = function(Double n_true, Double n_false, Double n_vars, String method)
  return (Double impurity)
{
  impurity = 0
  prob_true = n_true / (n_true + n_false)
  prob_false = n_false / (n_true + n_false)
  weight = (n_true + n_false) / n_vars

  if (prob_true != 1 & prob_false != 1) { # if there is more than one class, calculate new impurity according to method.
    if (method == "entropy") {
      scale_log = log(2) # scales the result for easier testing.
      impurity = (-1) * weight * (prob_true * log(prob_true)/scale_log + prob_false * log(prob_false)/scale_log)
    } else if (method == "gini") {
      impurity = weight * (1 - (prob_true^2 + prob_false^2))
    }
  }
}

# for now not very efficient equal width binning...
applyBinning = function(Matrix[Double] feature, Double bins)
  return (Matrix[Double] output_f)
{
  n_bins = max(bins, nrow(feature))
  max_v = max(feature)
  min_v = min(feature)
  width = (max_v - min_v) / n_bins
  output_f = matrix(1, rows = nrow(feature), cols = 1)

  for (i in 1:nrow(feature)) {
    c_value = as.scalar(feature[i,])
    filled = 0
    for (j in 1:n_bins) {
      if (c_value <= (min_v + j * width) & filled == 0) {
        output_f[i,] = j
        filled = 1
      }
    }
  }
}
