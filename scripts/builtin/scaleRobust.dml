m_scaleRobust = function(Matrix[Double] X)
  return (Matrix[Double] Y, Matrix[Double] med, Matrix[Double] iqr)
{
  n = nrow(X)
  m = ncol(X)

  med = matrix(0.0, rows=1, cols=m)
  q1  = matrix(0.0, rows=1, cols=m)
  q3  = matrix(0.0, rows=1, cols=m)

  # Loop over columns to compute quantiles
  for (j in 1:m) {
    col_j = X[,j]                        # get column vector
    med[1,j] = quantile(col_j, 0.5)
    q1[1,j]  = quantile(col_j, 0.25)
    q3[1,j]  = quantile(col_j, 0.75)
  }

  iqr = q3 - q1

  # Logging
  if (ncol(X) > 0) {
    print("DML column 1:")
    print("Q1:"); print(q1[1,1])
    print("Median:"); print(med[1,1])
    print("Q3:"); print(q3[1,1])
    print("IQR:"); print(iqr[1,1])
  }

  if (ncol(X) > 1) {
    print("DML column 2:")
    print("Q1:"); print(q1[1,2])
    print("Median:"); print(med[1,2])
    print("Q3:"); print(q3[1,2])
    print("IQR:"); print(iqr[1,2])
  }

  # Prevent division by 0 or NaN
  iqr = replace(target=iqr, pattern=0, replacement=1)
  iqr = replace(target=iqr, pattern=NaN, replacement=1)

  # Robust scale
  Y = (X - med) / iqr
}
