#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

source("nn/layers/attention.dml") as attention
source("nn/layers/affine.dml") as affine
source("nn/layers/lstm.dml") as lstm
source("nn/layers/relu.dml") as relu
source("nn/layers/sigmoid.dml") as sigmoid
source("nn/optim/adam.dml") as adam
source("nn/layers/log_loss.dml") as log_loss


# 1 get data
data_loc = "scripts/nn/examples/data/"
tableschema = "string,int"
N=32000
n=32000
max_length = 32
data = read(data_loc + "clickbait_data.csv", format="csv", header=TRUE, sep=",", data_type="frame", schema=tableschema, cols=2, rows=N)
#print(toString(data[1:10]))

[x_train, y_train, vocab_size] = preprocess(data, max_length, n)

# train network
# TODO fix: get error when batch size is not always equal
epochs = 30
batch_size = 32
val_size = batch_size * 200
[biases, weights, out0, c0] = train(x_train, y_train, epochs, batch_size, max_length, vocab_size, val_size)


preprocess = function(frame[unknown] data, integer max_length, integer n)
  return (matrix[double] features, matrix[double] targets, integer vocab_size)
{
  # map to lowercase, remove non alphanumeric characters
  formatted = map(data[,1], "x -> x.toLowerCase().replaceAll(\"[^\\p{Alnum}]+\", \" \").replaceAll(\"[\\s]+\", \" \")")
  ids = as.frame(seq(1,nrow(formatted),1))
  formatted = cbind(ids, formatted)
  #print(toString(formatted[1:100]))
  # prepare feature matrix for lstm into one-hot-encoded sequences
  spec = "{\"algo\" : \"split\", \"out\": \"position\", \"tokenize_col\": 2, \"id_cols\": [1]}"
  tokenized = tokenize(target=formatted, spec=spec, max_tokens=max_length)
  recode_spec = "{ \"recode\": [C3]}"
  [tokens, mapping] = transformencode(target=tokenized, spec=recode_spec)
  features = matrix(0, rows=n, cols=max_length)
  row_old = as.scalar(tokens[1,1])
  pos = 1
  for(i in 1:nrow(tokens))
  {
    row = as.scalar(tokens[i,1])
    if (row != row_old)
    {
      row_old = row
      pos = 1
    }
    features[row,pos] = tokens[i,3]
    pos += 1
  }
  features = replace(target=features, pattern = NaN, replacement = -1)
  features = features + 2
  vocab_size = as.integer(max(features))
  #features = toOneHot(features, num_classes)
  #print(toString(features[1:20,1:20]))
  targets = as.matrix(data[,2])
}

train = function( matrix[double] x_train,
                  matrix[double] y_train,
                  integer epochs,
                  integer batch_size,
                  integer max_sequence_length,
                  integer vocab_size,
                  integer val_size
)
  return(List[unknown] biases, List[unknown] weights, matrix[double] out0, matrix[double] c0)
{
  samples = nrow(x_train)

  #validation split
  x_val = x_train[1:val_size]
  y_val = y_train[1:val_size]

  x_train = x_train[val_size+1:samples]
  y_train = y_train[val_size+1:samples]

  samples = nrow(x_train)

  features = ncol(x_train)
  output_size = 1

  # We use a trainable embedding, each row is an embedding for a word
  embedding_size = 64
  W_E = rand(rows=vocab_size, cols=embedding_size)

  # 1 lstm layer
  lstm_neurons = 150
  [W_0, b_0, out0, c0] = lstm::init(batch_size, embedding_size, lstm_neurons)

  # 2 attention layer: no weights

  # 3 dense layer -> (hidden_size)
  hidden_neurons = 128

  [W_1, b_1] = affine::init(max_sequence_length * lstm_neurons, hidden_neurons, -1)

  # 4 dense layer -> (output_size)
  [W_2, b_2] = affine::init(hidden_neurons, output_size, -1)

  # 5 sigmoid layer: no weights

  # put weights & biases into list
  biases = list(b_0, b_1, b_2)
  weights = list(W_0, W_1, W_2, W_E)

  #optimizer init
  [mW_E, vW_E] = adam::init(W_E)

  [mout0, vout0] = adam::init(out0)
  [mc0, vc0] = adam::init(c0)

  [mW_0, vW_0] = adam::init(W_0)
  [mW_1, vW_1] = adam::init(W_1)
  [mW_2, vW_2] = adam::init(W_2)

  [mb_0, vb_0] = adam::init(b_0)
  [mb_1, vb_1] = adam::init(b_1)
  [mb_2, vb_2] = adam::init(b_2)

  #optimizer params
  lr = 0.001
  beta1 = 0.99
  beta2 = 0.999
  epsilon = 1e-8
  t = 0

  #training loop
  iters = ceil(samples/batch_size)
  for (ep in 1:epochs)
  {
    loss = 0
    for (i in 1:iters)
    {
      # 1 Get batch data
      start = ((i-1) * batch_size) %% samples + 1
      end = min(samples, start + batch_size -1)
      #TODO fix batch size problem

      x_batch = x_train[start:end,]
      y_batch = y_train[start:end,]

      # 2 predict
      [y_hat, out5, out4, out3, out2, out1, emb, cache_out_out, cache_c_out, cache_ifog_out] =
          predict(x_batch, biases, weights, max_sequence_length, embedding_size, out0, c0)

      # 3 loss
      loss = loss + log_loss::forward(y_hat, y_batch)

      # 3 backpropagation

      dout = log_loss::backward(y_hat, y_batch)
      dprobs = sigmoid::backward(dout, out5)
      [dout_2, dW_2, db_2] = affine::backward(dprobs, out4, W_2, b_2)
      drelu = relu::backward(dout_2, out3)
      [dout_1, dW_1, db_1] = affine::backward(drelu, out2, W_1, b_1)
      datt = attention::backward(dout_1, out1, out1, out1, max_sequence_length)
      dc = matrix(0, rows=nrow(x_batch), cols=lstm_neurons)
      [dEmb, dW_0, db_0, dout0, dc0] = lstm::backward(datt,
                                                        dc,
                                                        emb,
                                                        W_0,
                                                        b_0,
                                                        max_sequence_length,
                                                        embedding_size,
                                                        TRUE,
                                                        out0,
                                                        c0,
                                                        cache_out_out,
                                                        cache_c_out,
                                                        cache_ifog_out)

      # 4 update weights & biases

      t = ep * i - 1
      # #embedding
      [W_E, mW_E, vW_E] = update_embeddings(x_batch, dEmb, W_E, mW_E, vW_E,
        lr, beta1, beta2, epsilon, t, max_sequence_length, embedding_size)

      # lstm
      [c0 , mc0 , vc0 ] = adam::update(c0 , dc0 , lr, beta1, beta2, epsilon, t, mc0 , vc0 )
      [out0,mout0,vout0]= adam::update(out0,dout0,lr, beta1, beta2, epsilon, t,mout0,vout0)
      [b_0, mb_0, vb_0] = adam::update(b_0, db_0, lr, beta1, beta2, epsilon, t, mb_0, vb_0)
      [W_0, mW_0, vW_0] = adam::update(W_0, dW_0, lr, beta1, beta2, epsilon, t, mW_0, vW_0)

      #first affine
      [b_1, mb_1, vb_1] = adam::update(b_1, db_1, lr, beta1, beta2, epsilon, t, mb_1, vb_1)
      [W_1, mW_1, vW_1] = adam::update(W_1, dW_1, lr, beta1, beta2, epsilon, t, mW_1, vW_1)

      #second affine
      [b_2, mb_2, vb_2] = adam::update(b_2, db_2, lr, beta2, beta2, epsilon, t, mb_2, vb_2)
      [W_2, mW_2, vW_2] = adam::update(W_2, dW_2, lr, beta2, beta2, epsilon, t, mW_2, vW_2)

      # put weights & biases into list
      biases = list(b_0,b_1,b_2)
      weights = list(W_0,W_1,W_2,W_E)

    }
    val_loss = evaluate(x_val, y_val, biases, weights, out0, c0, max_sequence_length, embedding_size, batch_size)
    loss = loss / iters
    print("Epoch: " + ep + "; Train Loss: " + loss + "; Val. Loss: " + val_loss)
  }
}

predict = function( matrix[double] x,
                    List[unknown] biases,
                    List[unknown] weights,
                    integer max_sequence_length,
                    integer embedding_size,
                    matrix[double] out0,
                    matrix[double] c0)
  return (matrix[double] y_hat, matrix[double] out5, matrix[double] out4, matrix[double] out3,
          matrix[double] out2, matrix[double] out1, matrix[double] emb, matrix[double] cache_out_out,
          matrix[double] cache_c_out, matrix[double] cache_ifog_out)
{
  # unpack weights & biases
  W_0 = as.matrix(weights[1])
  W_1 = as.matrix(weights[2])
  W_2 = as.matrix(weights[3])
  W_E = as.matrix(weights[4])

  b_0 = as.matrix(biases[1])
  b_1 = as.matrix(biases[2])
  b_2 = as.matrix(biases[3])

  # fetch embedding
  emb = fetch_embeddings(x, W_E, max_sequence_length, embedding_size)
  # put input through layers
  [out1, c_out, cache_out_out, cache_c_out, cache_ifog_out]=
    lstm::forward(emb, W_0, b_0, max_sequence_length, embedding_size, TRUE, out0, c0)
  out2 = attention::forward(out1, out1, out1, max_sequence_length)
  out2 = out1
  out3 = affine::forward(out1, W_1, b_1)
  out4 = relu::forward(out3)
  out5 = affine::forward(out4, W_2, b_2)
  y_hat = sigmoid::forward(out5)
}

fetch_embeddings = function(matrix[double] indexes, matrix[double] W_E,
  integer max_sequence_length, integer embedding_size)
  return(matrix[double] emb)
{
emb = matrix(0, rows=nrow(indexes), cols=embedding_size*max_sequence_length)
  for (i in 1:nrow(indexes))
  {
    for (j in 1:max_sequence_length)
    {
      index = as.integer(as.scalar(indexes[i,j]))
      emb[i,(j-1)*embedding_size+1:j*embedding_size] = W_E[index]
    }
  }
}

update_embeddings = function(matrix[double] indexes, matrix[double] dEmb, matrix[double] W_E,
  matrix[double] mW_E, matrix[double] vW_E, double lr, double beta1, double beta2,
  double epsilon, integer t, integer max_sequence_length, integer embedding_size)
  return (matrix[double] W_E, matrix[double] mW_E, matrix[double] vW_E)
{
  for (i in 1:nrow(indexes))
  {
    for (j in 1:max_sequence_length)
    {
      index = as.integer(as.scalar(indexes[i,j]))
      [W_Ei, mW_Ei, vW_Ei] = adam::update(
        W_E[index], dEmb[i,(j-1)*embedding_size+1:j*embedding_size], lr, beta1, beta2,
        epsilon, t, mW_E[index], vW_E[index])
      W_E[index] = W_Ei
      mW_E[index] = mW_Ei
      vW_E[index] = vW_Ei
    }
  }
}

evaluate = function(matrix[double] x, matrix[double] y,
  list[unknown] biases, list[unknown] weights, matrix[double] out0, matrix[double] c0,
  integer max_sequence_length, integer embedding_size, integer batch_size)
  return(double loss)
{
  samples = nrow(x)
  iters = ceil(samples/batch_size)
  loss = 0
  for (i in 1:iters)
  {
    [y_hat, out5, out4, out3, out2, out1, emb, cache_out_out, cache_c_out, cache_ifog_out] =
    predict(x, biases, weights, max_sequence_length, embedding_size, out0, c0)
    loss = loss + log_loss::forward(y_hat, y)
  }
  loss = loss / iters
}
