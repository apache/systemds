#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

/*
 * AlexNet with LARS (Layer-wise Adaptive Rate Scaling) Integration
 * 
 * Reference: "ImageNet Classification with Deep Convolutional Neural Networks"
 * by Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton (2012)
 * 
 * LARS Reference: "Large Batch Training of Convolutional Networks"
 * by Yang You, Igor Gitman, and Boris Ginsburg (2017)
 * 
 * This implementation uses the existing correct LARS optimizer (lars.dml)
 * and learning rate utilities (lars_util.dml).
 */

# Import existing LARS modules
source("nn/optim/lars.dml") as lars
source("nn/optim/lars_util.dml") as lars_util

# Import layer implementations
source("nn/layers/affine.dml") as affine
source("nn/layers/conv2d_builtin.dml") as conv2d
source("nn/layers/cross_entropy_loss.dml") as cross_entropy_loss
source("nn/layers/dropout.dml") as dropout
source("nn/layers/l2_reg.dml") as l2_reg
source("nn/layers/max_pool2d_builtin.dml") as max_pool2d
source("nn/layers/relu.dml") as relu
source("nn/layers/softmax.dml") as softmax
source("nn/layers/batch_norm2d.dml") as batch_norm2d

/*
 * Forward and backward pass implementations
 */

forward = function(matrix[double] X, int C, int Hin, int Win,
                   list[unknown] model, string mode, double dropout_prob)
    return (matrix[double] out, list[unknown] cached_out) {
  /*
   * Forward pass of the AlexNet model.
   *
   * Architecture:
   * - Conv1: 96 filters, 11x11, stride 4, pad 0 → ReLU → MaxPool 3x3, stride 2
   * - Conv2: 256 filters, 5x5, stride 1, pad 2 → ReLU → MaxPool 3x3, stride 2  
   * - Conv3: 384 filters, 3x3, stride 1, pad 1 → ReLU
   * - Conv4: 384 filters, 3x3, stride 1, pad 1 → ReLU
   * - Conv5: 256 filters, 3x3, stride 1, pad 1 → ReLU → MaxPool 3x3, stride 2
   * - FC1: 4096 neurons → ReLU → Dropout
   * - FC2: 4096 neurons → ReLU → Dropout
   * - FC3: num_classes neurons → Softmax
   */
  
  # Extract model parameters
  W1 = as.matrix(model[1]); b1 = as.matrix(model[2])
  W2 = as.matrix(model[3]); b2 = as.matrix(model[4])
  W3 = as.matrix(model[5]); b3 = as.matrix(model[6])
  W4 = as.matrix(model[7]); b4 = as.matrix(model[8])
  W5 = as.matrix(model[9]); b5 = as.matrix(model[10])
  W6 = as.matrix(model[11]); b6 = as.matrix(model[12])
  W7 = as.matrix(model[13]); b7 = as.matrix(model[14])
  W8 = as.matrix(model[15]); b8 = as.matrix(model[16])

  # Forward pass
  # Conv1 → ReLU → MaxPool1
  [outc1, Houtc1, Woutc1] = conv2d::forward(X, W1, b1, C, Hin, Win, 11, 11, 4, 4, 0, 0)
  outr1 = relu::forward(outc1)
  [outp1, Houtp1, Woutp1] = max_pool2d::forward(outr1, 96, Houtc1, Woutc1, 3, 3, 2, 2, 0, 0)
  
  # Conv2 → ReLU → MaxPool2
  [outc2, Houtc2, Woutc2] = conv2d::forward(outp1, W2, b2, 96, Houtp1, Woutp1, 5, 5, 1, 1, 2, 2)
  outr2 = relu::forward(outc2)
  [outp2, Houtp2, Woutp2] = max_pool2d::forward(outr2, 256, Houtc2, Woutc2, 3, 3, 2, 2, 0, 0)
  
  # Conv3 → ReLU
  [outc3, Houtc3, Woutc3] = conv2d::forward(outp2, W3, b3, 256, Houtp2, Woutp2, 3, 3, 1, 1, 1, 1)
  outr3 = relu::forward(outc3)
  
  # Conv4 → ReLU
  [outc4, Houtc4, Woutc4] = conv2d::forward(outr3, W4, b4, 384, Houtc3, Woutc3, 3, 3, 1, 1, 1, 1)
  outr4 = relu::forward(outc4)
  
  # Conv5 → ReLU → MaxPool3
  [outc5, Houtc5, Woutc5] = conv2d::forward(outr4, W5, b5, 384, Houtc4, Woutc4, 3, 3, 1, 1, 1, 1)
  outr5 = relu::forward(outc5)
  [outp5, Houtp5, Woutp5] = max_pool2d::forward(outr5, 256, Houtc5, Woutc5, 3, 3, 2, 2, 0, 0)
  
  # FC1 → ReLU → Dropout
  outa6 = affine::forward(outp5, W6, b6)
  outr6 = relu::forward(outa6)
  if (mode == "train") {
    [outd6, maskd6] = dropout::forward(outr6, dropout_prob, -1)
  } else {
    outd6 = outr6
    maskd6 = matrix(1, rows=nrow(outr6), cols=ncol(outr6))
  }
  
  # FC2 → ReLU → Dropout
  outa7 = affine::forward(outd6, W7, b7)
  outr7 = relu::forward(outa7)
  if (mode == "train") {
    [outd7, maskd7] = dropout::forward(outr7, dropout_prob, -1)
  } else {
    outd7 = outr7
    maskd7 = matrix(1, rows=nrow(outr7), cols=ncol(outr7))
  }
  
  # FC3 → Softmax
  outa8 = affine::forward(outd7, W8, b8)
  out = softmax::forward(outa8)

  # Cache intermediate outputs for backward pass
  cached_out = list(X, outc1, Houtc1, Woutc1, outr1, outp1, Houtp1, Woutp1,
                    outc2, Houtc2, Woutc2, outr2, outp2, Houtp2, Woutp2,
                    outc3, Houtc3, Woutc3, outr3, outc4, Houtc4, Woutc4, outr4,
                    outc5, Houtc5, Woutc5, outr5, outp5, Houtp5, Woutp5,
                    outa6, outr6, outd6, maskd6, outa7, outr7, outd7, maskd7, outa8)
}

backward = function(matrix[double] dOut, list[unknown] cached_out,
                    list[unknown] model, int C, int Hin, int Win, double dropout_prob)
    return (matrix[double] dX, list[unknown] gradients) {
  /*
   * Backward pass of the AlexNet model.
   */
  
  # Extract model parameters
  W1 = as.matrix(model[1]); b1 = as.matrix(model[2])
  W2 = as.matrix(model[3]); b2 = as.matrix(model[4])
  W3 = as.matrix(model[5]); b3 = as.matrix(model[6])
  W4 = as.matrix(model[7]); b4 = as.matrix(model[8])
  W5 = as.matrix(model[9]); b5 = as.matrix(model[10])
  W6 = as.matrix(model[11]); b6 = as.matrix(model[12])
  W7 = as.matrix(model[13]); b7 = as.matrix(model[14])
  W8 = as.matrix(model[15]); b8 = as.matrix(model[16])

  # Extract cached outputs
  X = as.matrix(cached_out[1])
  outc1 = as.matrix(cached_out[2]); Houtc1 = as.scalar(cached_out[3]); Woutc1 = as.scalar(cached_out[4])
  outr1 = as.matrix(cached_out[5])
  outp1 = as.matrix(cached_out[6]); Houtp1 = as.scalar(cached_out[7]); Woutp1 = as.scalar(cached_out[8])
  outc2 = as.matrix(cached_out[9]); Houtc2 = as.scalar(cached_out[10]); Woutc2 = as.scalar(cached_out[11])
  outr2 = as.matrix(cached_out[12])
  outp2 = as.matrix(cached_out[13]); Houtp2 = as.scalar(cached_out[14]); Woutp2 = as.scalar(cached_out[15])
  outc3 = as.matrix(cached_out[16]); Houtc3 = as.scalar(cached_out[17]); Woutc3 = as.scalar(cached_out[18])
  outr3 = as.matrix(cached_out[19])
  outc4 = as.matrix(cached_out[20]); Houtc4 = as.scalar(cached_out[21]); Woutc4 = as.scalar(cached_out[22])
  outr4 = as.matrix(cached_out[23])
  outc5 = as.matrix(cached_out[24]); Houtc5 = as.scalar(cached_out[25]); Woutc5 = as.scalar(cached_out[26])
  outr5 = as.matrix(cached_out[27])
  outp5 = as.matrix(cached_out[28]); Houtp5 = as.scalar(cached_out[29]); Woutp5 = as.scalar(cached_out[30])
  outa6 = as.matrix(cached_out[31]); outr6 = as.matrix(cached_out[32])
  outd6 = as.matrix(cached_out[33]); maskd6 = as.matrix(cached_out[34])
  outa7 = as.matrix(cached_out[35]); outr7 = as.matrix(cached_out[36])
  outd7 = as.matrix(cached_out[37]); maskd7 = as.matrix(cached_out[38])
  outa8 = as.matrix(cached_out[39])

  # Backward pass
  # FC3
  douta8 = softmax::backward(dOut, outa8)
  [doutd7, dW8, db8] = affine::backward(douta8, outd7, W8, b8)
  
  # FC2
  doutr7 = dropout::backward(doutd7, outr7, dropout_prob, maskd7)
  douta7 = relu::backward(doutr7, outa7)
  [doutd6, dW7, db7] = affine::backward(douta7, outd6, W7, b7)
  
  # FC1
  doutr6 = dropout::backward(doutd6, outr6, dropout_prob, maskd6)
  douta6 = relu::backward(doutr6, outa6)
  [doutp5, dW6, db6] = affine::backward(douta6, outp5, W6, b6)
  
  # Conv5
  doutr5 = max_pool2d::backward(doutp5, Houtp5, Woutp5, outr5, 256, Houtc5, Woutc5, 3, 3, 2, 2, 0, 0)
  doutc5 = relu::backward(doutr5, outc5)
  [doutr4, dW5, db5] = conv2d::backward(doutc5, Houtc5, Woutc5, outr4, W5, b5, 384, Houtc4, Woutc4, 3, 3, 1, 1, 1, 1)
  
  # Conv4
  doutc4 = relu::backward(doutr4, outc4)
  [doutr3, dW4, db4] = conv2d::backward(doutc4, Houtc4, Woutc4, outr3, W4, b4, 384, Houtc3, Woutc3, 3, 3, 1, 1, 1, 1)
  
  # Conv3
  doutc3 = relu::backward(doutr3, outc3)
  [doutp2, dW3, db3] = conv2d::backward(doutc3, Houtc3, Woutc3, outp2, W3, b3, 256, Houtp2, Woutp2, 3, 3, 1, 1, 1, 1)
  
  # Conv2
  doutr2 = max_pool2d::backward(doutp2, Houtp2, Woutp2, outr2, 256, Houtc2, Woutc2, 3, 3, 2, 2, 0, 0)
  doutc2 = relu::backward(doutr2, outc2)
  [doutp1, dW2, db2] = conv2d::backward(doutc2, Houtc2, Woutc2, outp1, W2, b2, 96, Houtp1, Woutp1, 5, 5, 1, 1, 2, 2)
  
  # Conv1
  doutr1 = max_pool2d::backward(doutp1, Houtp1, Woutp1, outr1, 96, Houtc1, Woutc1, 3, 3, 2, 2, 0, 0)
  doutc1 = relu::backward(doutr1, outc1)
  [dX, dW1, db1] = conv2d::backward(doutc1, Houtc1, Woutc1, X, W1, b1, C, Hin, Win, 11, 11, 4, 4, 0, 0)

  # Package gradients
  gradients = list(dW1, db1, dW2, db2, dW3, db3, dW4, db4, dW5, db5, dW6, db6, dW7, db7, dW8, db8)
}

/*
 * AlexNet-BN variant with Batch Normalization
 */

forward_with_bn = function(matrix[double] X, int C, int Hin, int Win,
                          list[unknown] model, string mode, double dropout_prob)
    return (matrix[double] out, list[unknown] cached_out, list[unknown] emas_upd) {
  /*
   * Forward pass of the AlexNet-BN model (with Batch Normalization).
   *
   * Architecture:
   * - Conv1 → BN → ReLU → MaxPool
   * - Conv2 → BN → ReLU → MaxPool
   * - Conv3 → BN → ReLU
   * - Conv4 → BN → ReLU
   * - Conv5 → BN → ReLU → MaxPool
   * - FC1 → ReLU → Dropout
   * - FC2 → ReLU → Dropout
   * - FC3 → Softmax
   */
  
  # Extract model parameters (with BN)
  W1 = as.matrix(model[1]); b1 = as.matrix(model[2])
  gamma1 = as.matrix(model[3]); beta1 = as.matrix(model[4])
  ema_mean1 = as.matrix(model[5]); ema_var1 = as.matrix(model[6])
  
  W2 = as.matrix(model[7]); b2 = as.matrix(model[8])
  gamma2 = as.matrix(model[9]); beta2 = as.matrix(model[10])
  ema_mean2 = as.matrix(model[11]); ema_var2 = as.matrix(model[12])
  
  W3 = as.matrix(model[13]); b3 = as.matrix(model[14])
  gamma3 = as.matrix(model[15]); beta3 = as.matrix(model[16])
  ema_mean3 = as.matrix(model[17]); ema_var3 = as.matrix(model[18])
  
  W4 = as.matrix(model[19]); b4 = as.matrix(model[20])
  gamma4 = as.matrix(model[21]); beta4 = as.matrix(model[22])
  ema_mean4 = as.matrix(model[23]); ema_var4 = as.matrix(model[24])
  
  W5 = as.matrix(model[25]); b5 = as.matrix(model[26])
  gamma5 = as.matrix(model[27]); beta5 = as.matrix(model[28])
  ema_mean5 = as.matrix(model[29]); ema_var5 = as.matrix(model[30])
  
  W6 = as.matrix(model[31]); b6 = as.matrix(model[32])
  W7 = as.matrix(model[33]); b7 = as.matrix(model[34])
  W8 = as.matrix(model[35]); b8 = as.matrix(model[36])

  # Forward pass with batch normalization
  # Conv1 → BN → ReLU → MaxPool
  [outc1, Houtc1, Woutc1] = conv2d::forward(X, W1, b1, C, Hin, Win, 11, 11, 4, 4, 0, 0)
  [outbn1, ema_mean1_upd, ema_var1_upd, cache_mean1, cache_inv_var1] = batch_norm2d::forward(outc1, gamma1, beta1, 96, Houtc1, Woutc1, mode, ema_mean1, ema_var1, 0.99, 1e-5)
  outr1 = relu::forward(outbn1)
  [outp1, Houtp1, Woutp1] = max_pool2d::forward(outr1, 96, Houtc1, Woutc1, 3, 3, 2, 2, 0, 0)
  
  # Conv2 → BN → ReLU → MaxPool
  [outc2, Houtc2, Woutc2] = conv2d::forward(outp1, W2, b2, 96, Houtp1, Woutp1, 5, 5, 1, 1, 2, 2)
  [outbn2, ema_mean2_upd, ema_var2_upd, cache_mean2, cache_inv_var2] = batch_norm2d::forward(outc2, gamma2, beta2, 256, Houtc2, Woutc2, mode, ema_mean2, ema_var2, 0.99, 1e-5)
  outr2 = relu::forward(outbn2)
  [outp2, Houtp2, Woutp2] = max_pool2d::forward(outr2, 256, Houtc2, Woutc2, 3, 3, 2, 2, 0, 0)
  
  # Conv3 → BN → ReLU
  [outc3, Houtc3, Woutc3] = conv2d::forward(outp2, W3, b3, 256, Houtp2, Woutp2, 3, 3, 1, 1, 1, 1)
  [outbn3, ema_mean3_upd, ema_var3_upd, cache_mean3, cache_inv_var3] = batch_norm2d::forward(outc3, gamma3, beta3, 384, Houtc3, Woutc3, mode, ema_mean3, ema_var3, 0.99, 1e-5)
  outr3 = relu::forward(outbn3)
  
  # Conv4 → BN → ReLU
  [outc4, Houtc4, Woutc4] = conv2d::forward(outr3, W4, b4, 384, Houtc3, Woutc3, 3, 3, 1, 1, 1, 1)
  [outbn4, ema_mean4_upd, ema_var4_upd, cache_mean4, cache_inv_var4] = batch_norm2d::forward(outc4, gamma4, beta4, 384, Houtc4, Woutc4, mode, ema_mean4, ema_var4, 0.99, 1e-5)
  outr4 = relu::forward(outbn4)
  
  # Conv5 → BN → ReLU → MaxPool
  [outc5, Houtc5, Woutc5] = conv2d::forward(outr4, W5, b5, 384, Houtc4, Woutc4, 3, 3, 1, 1, 1, 1)
  [outbn5, ema_mean5_upd, ema_var5_upd, cache_mean5, cache_inv_var5] = batch_norm2d::forward(outc5, gamma5, beta5, 256, Houtc5, Woutc5, mode, ema_mean5, ema_var5, 0.99, 1e-5)
  outr5 = relu::forward(outbn5)
  [outp5, Houtp5, Woutp5] = max_pool2d::forward(outr5, 256, Houtc5, Woutc5, 3, 3, 2, 2, 0, 0)
  
  # FC1 → ReLU → Dropout
  outa6 = affine::forward(outp5, W6, b6)
  outr6 = relu::forward(outa6)
  if (mode == "train") {
    [outd6, maskd6] = dropout::forward(outr6, dropout_prob, -1)
  } else {
    outd6 = outr6
    maskd6 = matrix(1, rows=nrow(outr6), cols=ncol(outr6))
  }
  
  # FC2 → ReLU → Dropout
  outa7 = affine::forward(outd6, W7, b7)
  outr7 = relu::forward(outa7)
  if (mode == "train") {
    [outd7, maskd7] = dropout::forward(outr7, dropout_prob, -1)
  } else {
    outd7 = outr7
    maskd7 = matrix(1, rows=nrow(outr7), cols=ncol(outr7))
  }
  
  # FC3 → Softmax
  outa8 = affine::forward(outd7, W8, b8)
  out = softmax::forward(outa8)

  # Cache intermediate outputs for backward pass
  cached_out = list(X, outc1, Houtc1, Woutc1, outbn1, cache_mean1, cache_inv_var1, outr1, outp1, Houtp1, Woutp1,
                    outc2, Houtc2, Woutc2, outbn2, cache_mean2, cache_inv_var2, outr2, outp2, Houtp2, Woutp2,
                    outc3, Houtc3, Woutc3, outbn3, cache_mean3, cache_inv_var3, outr3,
                    outc4, Houtc4, Woutc4, outbn4, cache_mean4, cache_inv_var4, outr4,
                    outc5, Houtc5, Woutc5, outbn5, cache_mean5, cache_inv_var5, outr5, outp5, Houtp5, Woutp5,
                    outa6, outr6, outd6, maskd6, outa7, outr7, outd7, maskd7, outa8)
  
  # Updated EMA parameters
  emas_upd = list(ema_mean1_upd, ema_var1_upd, ema_mean2_upd, ema_var2_upd, ema_mean3_upd, ema_var3_upd,
                  ema_mean4_upd, ema_var4_upd, ema_mean5_upd, ema_var5_upd)
}

backward_with_bn = function(matrix[double] dOut, list[unknown] cached_out,
                           list[unknown] model, int C, int Hin, int Win, double dropout_prob)
    return (matrix[double] dX, list[unknown] gradients) {
  /*
   * Backward pass of the AlexNet-BN model.
   */
  
  # Ensure dOut is dense to avoid sparse matrix issues
  dOut = matrix(dOut, rows=nrow(dOut), cols=ncol(dOut))
  
  # Extract model parameters (BN version)
  W1 = as.matrix(model[1]); b1 = as.matrix(model[2])
  gamma1 = as.matrix(model[3]); beta1 = as.matrix(model[4])
  
  W2 = as.matrix(model[7]); b2 = as.matrix(model[8])
  gamma2 = as.matrix(model[9]); beta2 = as.matrix(model[10])
  
  W3 = as.matrix(model[13]); b3 = as.matrix(model[14])
  gamma3 = as.matrix(model[15]); beta3 = as.matrix(model[16])
  
  W4 = as.matrix(model[19]); b4 = as.matrix(model[20])
  gamma4 = as.matrix(model[21]); beta4 = as.matrix(model[22])
  
  W5 = as.matrix(model[25]); b5 = as.matrix(model[26])
  gamma5 = as.matrix(model[27]); beta5 = as.matrix(model[28])
  
  W6 = as.matrix(model[31]); b6 = as.matrix(model[32])
  W7 = as.matrix(model[33]); b7 = as.matrix(model[34])
  W8 = as.matrix(model[35]); b8 = as.matrix(model[36])

  # Extract cached outputs (BN version - more complex)
  X = as.matrix(cached_out[1])
  outc1 = as.matrix(cached_out[2]); Houtc1 = as.scalar(cached_out[3]); Woutc1 = as.scalar(cached_out[4])
  outbn1 = as.matrix(cached_out[5]); cache_mean1 = as.matrix(cached_out[6]); cache_inv_var1 = as.matrix(cached_out[7])
  outr1 = as.matrix(cached_out[8])
  outp1 = as.matrix(cached_out[9]); Houtp1 = as.scalar(cached_out[10]); Woutp1 = as.scalar(cached_out[11])
  
  outc2 = as.matrix(cached_out[12]); Houtc2 = as.scalar(cached_out[13]); Woutc2 = as.scalar(cached_out[14])
  outbn2 = as.matrix(cached_out[15]); cache_mean2 = as.matrix(cached_out[16]); cache_inv_var2 = as.matrix(cached_out[17])
  outr2 = as.matrix(cached_out[18])
  outp2 = as.matrix(cached_out[19]); Houtp2 = as.scalar(cached_out[20]); Woutp2 = as.scalar(cached_out[21])
  
  outc3 = as.matrix(cached_out[22]); Houtc3 = as.scalar(cached_out[23]); Woutc3 = as.scalar(cached_out[24])
  outbn3 = as.matrix(cached_out[25]); cache_mean3 = as.matrix(cached_out[26]); cache_inv_var3 = as.matrix(cached_out[27])
  outr3 = as.matrix(cached_out[28])
  
  outc4 = as.matrix(cached_out[29]); Houtc4 = as.scalar(cached_out[30]); Woutc4 = as.scalar(cached_out[31])
  outbn4 = as.matrix(cached_out[32]); cache_mean4 = as.matrix(cached_out[33]); cache_inv_var4 = as.matrix(cached_out[34])
  outr4 = as.matrix(cached_out[35])
  
  outc5 = as.matrix(cached_out[36]); Houtc5 = as.scalar(cached_out[37]); Woutc5 = as.scalar(cached_out[38])
  outbn5 = as.matrix(cached_out[39]); cache_mean5 = as.matrix(cached_out[40]); cache_inv_var5 = as.matrix(cached_out[41])
  outr5 = as.matrix(cached_out[42])
  outp5 = as.matrix(cached_out[43]); Houtp5 = as.scalar(cached_out[44]); Woutp5 = as.scalar(cached_out[45])
  
  outa6 = as.matrix(cached_out[46]); outr6 = as.matrix(cached_out[47])
  outd6 = as.matrix(cached_out[48]); maskd6 = as.matrix(cached_out[49])
  outa7 = as.matrix(cached_out[50]); outr7 = as.matrix(cached_out[51])
  outd7 = as.matrix(cached_out[52]); maskd7 = as.matrix(cached_out[53])
  outa8 = as.matrix(cached_out[54])

  # Try-catch mechanism: If real backward pass fails, use dummy gradients
  # This is a temporary workaround for the sparse matrix issue
  try_real_backward = TRUE  # Enable real backward to debug the issue
  
  if (try_real_backward) {
    # Backward pass with debugging
    print("DEBUG: Starting backward pass")
    
    # FC3
    print("DEBUG: FC3 backward - dOut shape: " + nrow(dOut) + "x" + ncol(dOut))
    douta8 = softmax::backward(dOut, outa8)
    douta8 = matrix(douta8, rows=nrow(douta8), cols=ncol(douta8))  # Ensure dense
    [doutd7, dW8, db8] = affine::backward(douta8, outd7, W8, b8)
    
    # FC2
    print("DEBUG: FC2 backward")
    doutd7 = matrix(doutd7, rows=nrow(doutd7), cols=ncol(doutd7))  # Ensure dense
    doutr7 = dropout::backward(doutd7, outr7, dropout_prob, maskd7)
    doutr7 = matrix(doutr7, rows=nrow(doutr7), cols=ncol(doutr7))  # Ensure dense
    douta7 = relu::backward(doutr7, outa7)
    douta7 = matrix(douta7, rows=nrow(douta7), cols=ncol(douta7))  # Ensure dense
    [doutd6, dW7, db7] = affine::backward(douta7, outd6, W7, b7)
    
    # FC1
    print("DEBUG: FC1 backward")
    doutd6 = matrix(doutd6, rows=nrow(doutd6), cols=ncol(doutd6))  # Ensure dense
    doutr6 = dropout::backward(doutd6, outr6, dropout_prob, maskd6)
    doutr6 = matrix(doutr6, rows=nrow(doutr6), cols=ncol(doutr6))  # Ensure dense
    douta6 = relu::backward(doutr6, outa6)
    douta6 = matrix(douta6, rows=nrow(douta6), cols=ncol(douta6))  # Ensure dense
    [doutp5, dW6, db6] = affine::backward(douta6, outp5, W6, b6)
    
    # Conv5 → BN → ReLU → MaxPool
    print("DEBUG: Conv5 backward")
    doutp5 = matrix(doutp5, rows=nrow(doutp5), cols=ncol(doutp5))  # Ensure dense
    doutr5 = max_pool2d::backward(doutp5, Houtp5, Woutp5, outr5, 256, Houtc5, Woutc5, 3, 3, 2, 2, 0, 0)
    doutr5 = matrix(doutr5, rows=nrow(doutr5), cols=ncol(doutr5))  # Ensure dense
    doutbn5 = relu::backward(doutr5, outbn5)
    doutbn5 = matrix(doutbn5, rows=nrow(doutbn5), cols=ncol(doutbn5))  # Ensure dense
    print("DEBUG: Before BN5 backward - doutbn5 shape: " + nrow(doutbn5) + "x" + ncol(doutbn5))
    [doutc5, dgamma5, dbeta5] = batch_norm2d::backward(doutbn5, cache_mean5, cache_inv_var5, outc5, gamma5, 256, Houtc5, Woutc5, 1e-5)
    doutc5 = matrix(doutc5, rows=nrow(doutc5), cols=ncol(doutc5))  # Ensure dense
    [doutr4, dW5, db5] = conv2d::backward(doutc5, Houtc5, Woutc5, outr4, W5, b5, 384, Houtc4, Woutc4, 3, 3, 1, 1, 1, 1)
    
    # Conv4 → BN → ReLU
    print("DEBUG: Conv4 backward")
    doutr4 = matrix(doutr4, rows=nrow(doutr4), cols=ncol(doutr4))  # Ensure dense
    doutbn4 = relu::backward(doutr4, outbn4)
    doutbn4 = matrix(doutbn4, rows=nrow(doutbn4), cols=ncol(doutbn4))  # Ensure dense
    print("DEBUG: Before BN4 backward")
    [doutc4, dgamma4, dbeta4] = batch_norm2d::backward(doutbn4, cache_mean4, cache_inv_var4, outc4, gamma4, 384, Houtc4, Woutc4, 1e-5)
    doutc4 = matrix(doutc4, rows=nrow(doutc4), cols=ncol(doutc4))  # Ensure dense
    [doutr3, dW4, db4] = conv2d::backward(doutc4, Houtc4, Woutc4, outr3, W4, b4, 384, Houtc3, Woutc3, 3, 3, 1, 1, 1, 1)
    
    # Conv3 → BN → ReLU
    print("DEBUG: Conv3 backward")
    doutr3 = matrix(doutr3, rows=nrow(doutr3), cols=ncol(doutr3))  # Ensure dense
    doutbn3 = relu::backward(doutr3, outbn3)
    doutbn3 = matrix(doutbn3, rows=nrow(doutbn3), cols=ncol(doutbn3))  # Ensure dense
    print("DEBUG: Before BN3 backward")
    [doutc3, dgamma3, dbeta3] = batch_norm2d::backward(doutbn3, cache_mean3, cache_inv_var3, outc3, gamma3, 384, Houtc3, Woutc3, 1e-5)
    doutc3 = matrix(doutc3, rows=nrow(doutc3), cols=ncol(doutc3))  # Ensure dense
    [doutp2, dW3, db3] = conv2d::backward(doutc3, Houtc3, Woutc3, outp2, W3, b3, 256, Houtp2, Woutp2, 3, 3, 1, 1, 1, 1)
    
    # Conv2 → BN → ReLU → MaxPool
    print("DEBUG: Conv2 backward")
    doutp2 = matrix(doutp2, rows=nrow(doutp2), cols=ncol(doutp2))  # Ensure dense
    doutr2 = max_pool2d::backward(doutp2, Houtp2, Woutp2, outr2, 256, Houtc2, Woutc2, 3, 3, 2, 2, 0, 0)
    doutr2 = matrix(doutr2, rows=nrow(doutr2), cols=ncol(doutr2))  # Ensure dense
    doutbn2 = relu::backward(doutr2, outbn2)
    doutbn2 = matrix(doutbn2, rows=nrow(doutbn2), cols=ncol(doutbn2))  # Ensure dense
    print("DEBUG: Before BN2 backward")
    [doutc2, dgamma2, dbeta2] = batch_norm2d::backward(doutbn2, cache_mean2, cache_inv_var2, outc2, gamma2, 256, Houtc2, Woutc2, 1e-5)
    doutc2 = matrix(doutc2, rows=nrow(doutc2), cols=ncol(doutc2))  # Ensure dense
    [doutp1, dW2, db2] = conv2d::backward(doutc2, Houtc2, Woutc2, outp1, W2, b2, 96, Houtp1, Woutp1, 5, 5, 1, 1, 2, 2)
    
    # Conv1 → BN → ReLU → MaxPool
    print("DEBUG: Conv1 backward")
    doutp1 = matrix(doutp1, rows=nrow(doutp1), cols=ncol(doutp1))  # Ensure dense
    doutr1 = max_pool2d::backward(doutp1, Houtp1, Woutp1, outr1, 96, Houtc1, Woutc1, 3, 3, 2, 2, 0, 0)
    doutr1 = matrix(doutr1, rows=nrow(doutr1), cols=ncol(doutr1))  # Ensure dense
    doutbn1 = relu::backward(doutr1, outbn1)
    doutbn1 = matrix(doutbn1, rows=nrow(doutbn1), cols=ncol(doutbn1))  # Ensure dense
    print("DEBUG: Before BN1 backward")
    [doutc1, dgamma1, dbeta1] = batch_norm2d::backward(doutbn1, cache_mean1, cache_inv_var1, outc1, gamma1, 96, Houtc1, Woutc1, 1e-5)
    doutc1 = matrix(doutc1, rows=nrow(doutc1), cols=ncol(doutc1))  # Ensure dense
    [dX, dW1, db1] = conv2d::backward(doutc1, Houtc1, Woutc1, X, W1, b1, C, Hin, Win, 11, 11, 4, 4, 0, 0)
    
    print("DEBUG: Backward pass completed successfully!")

    # Package gradients in same order as model parameters
    gradients = list(dW1, db1, dgamma1, dbeta1, matrix(0,rows=nrow(dgamma1),cols=ncol(dgamma1)), matrix(0,rows=nrow(dbeta1),cols=ncol(dbeta1)),  # EMA grads are 0
                     dW2, db2, dgamma2, dbeta2, matrix(0,rows=nrow(dgamma2),cols=ncol(dgamma2)), matrix(0,rows=nrow(dbeta2),cols=ncol(dbeta2)),
                     dW3, db3, dgamma3, dbeta3, matrix(0,rows=nrow(dgamma3),cols=ncol(dgamma3)), matrix(0,rows=nrow(dbeta3),cols=ncol(dbeta3)),
                     dW4, db4, dgamma4, dbeta4, matrix(0,rows=nrow(dgamma4),cols=ncol(dgamma4)), matrix(0,rows=nrow(dbeta4),cols=ncol(dbeta4)),
                     dW5, db5, dgamma5, dbeta5, matrix(0,rows=nrow(dgamma5),cols=ncol(dgamma5)), matrix(0,rows=nrow(dbeta5),cols=ncol(dbeta5)),
                     dW6, db6, dW7, db7, dW8, db8)
  } else {
    # TEMPORARY: Use approximate gradients based on loss to avoid sparse matrix issues
    # This is a workaround until the sparse matrix null pointer issue is resolved
    # The gradients are scaled based on the loss magnitude for more realistic updates
    
    N = nrow(dOut)
    loss_scale = sum(abs(dOut)) / (N * ncol(dOut))  # Average magnitude of loss gradient
    
    gradients = list()
    for (i in 1:length(model)) {
      param = as.matrix(model[i])
      # Create gradients proportional to parameter magnitude and loss
      grad = rand(rows=nrow(param), cols=ncol(param), min=-1, max=1, seed=i+42)
      grad = grad * loss_scale * 0.01  # Scale gradients appropriately
      gradients = append(gradients, grad)
    }
    
    # Dummy dX
    dX = matrix(0, rows=N, cols=C*Hin*Win)
  }
}

/*
 * Model initialization
 */

init = function(int C, int Hin, int Win, int num_classes, int seed)
    return (list[unknown] model) {
  /*
   * Initialize AlexNet model parameters.
   */
  
  # Calculate fully connected input size based on convolution output
  # After all convolutions and pooling: 5x5 feature maps with 256 channels
  fc_input_size = 256 * 5 * 5  # 6400
  
  # Initialize convolutional layers
  [W1, b1] = conv2d::init(96, C, 11, 11, seed)      # Conv1: 96 11x11 filters
  [W2, b2] = conv2d::init(256, 96, 5, 5, seed)      # Conv2: 256 5x5 filters  
  [W3, b3] = conv2d::init(384, 256, 3, 3, seed)     # Conv3: 384 3x3 filters
  [W4, b4] = conv2d::init(384, 384, 3, 3, seed)     # Conv4: 384 3x3 filters
  [W5, b5] = conv2d::init(256, 384, 3, 3, seed)     # Conv5: 256 3x3 filters

  # Initialize fully connected layers
  [W6, b6] = affine::init(fc_input_size, 4096, seed)  # FC1
  [W7, b7] = affine::init(4096, 4096, seed)           # FC2
  [W8, b8] = affine::init(4096, num_classes, seed)    # FC3 (output)
  
  # Scale final layer for better convergence
  W8 = W8 / sqrt(2)

  # Package model
  model = list(W1, b1, W2, b2, W3, b3, W4, b4, W5, b5, W6, b6, W7, b7, W8, b8)
}

init_with_bn = function(int C, int Hin, int Win, int num_classes, int seed)
    return (list[unknown] model, list[unknown] emas) {
  /*
   * Initialize AlexNet-BN model parameters (with Batch Normalization).
   */
  
  # Calculate fully connected input size
  fc_input_size = 256 * 5 * 5  # 6400
  
  # Initialize convolutional layers
  [W1, b1] = conv2d::init(96, C, 11, 11, seed)      # Conv1
  [W2, b2] = conv2d::init(256, 96, 5, 5, seed)      # Conv2
  [W3, b3] = conv2d::init(384, 256, 3, 3, seed)     # Conv3
  [W4, b4] = conv2d::init(384, 384, 3, 3, seed)     # Conv4
  [W5, b5] = conv2d::init(256, 384, 3, 3, seed)     # Conv5
  
  # Initialize batch normalization parameters for each conv layer
  [gamma1, beta1, ema_mean1, ema_var1] = batch_norm2d::init(96)
  [gamma2, beta2, ema_mean2, ema_var2] = batch_norm2d::init(256)
  [gamma3, beta3, ema_mean3, ema_var3] = batch_norm2d::init(384)
  [gamma4, beta4, ema_mean4, ema_var4] = batch_norm2d::init(384)
  [gamma5, beta5, ema_mean5, ema_var5] = batch_norm2d::init(256)
  
  # Initialize fully connected layers
  [W6, b6] = affine::init(fc_input_size, 4096, seed)  # FC1
  [W7, b7] = affine::init(4096, 4096, seed)           # FC2
  [W8, b8] = affine::init(4096, num_classes, seed)    # FC3 (output)
  
  # Scale final layer for better convergence
  W8 = W8 / sqrt(2)
  
  # Package model with BN parameters
  model = list(W1, b1, gamma1, beta1, ema_mean1, ema_var1,
               W2, b2, gamma2, beta2, ema_mean2, ema_var2,
               W3, b3, gamma3, beta3, ema_mean3, ema_var3,
               W4, b4, gamma4, beta4, ema_mean4, ema_var4,
               W5, b5, gamma5, beta5, ema_mean5, ema_var5,
               W6, b6, W7, b7, W8, b8)
  
  # Package EMA parameters for easy access
  emas = list(ema_mean1, ema_var1, ema_mean2, ema_var2, ema_mean3, ema_var3,
              ema_mean4, ema_var4, ema_mean5, ema_var5)
}

/*
 * LARS Integration Functions - Using your existing lars.dml implementation
 */

init_lars_optim_params = function(list[unknown] model)
    return (list[unknown] optim_state) {
  /*
   * Initialize LARS optimizer momentum state for each parameter.
   */
  optim_state = list()
  for (i in 1:length(model)) {
    param = as.matrix(model[i])
    momentum_state = lars::init(param)
    optim_state = append(optim_state, momentum_state)
  }
}

update_params_with_lars = function(list[unknown] model, list[unknown] gradients,
                                   double global_lr, double momentum, double weight_decay,
                                   double trust_coeff, list[unknown] optim_state)
    return (list[unknown] model_upd, list[unknown] optim_state_upd) {
  /*
   * Update model parameters with LARS optimizer using your existing lars.dml implementation.
   *
   * This function loops through all model parameters and calls your existing
   * lars::update() function for each parameter.
   */
  
  model_upd = list()
  optim_state_upd = list()
  
  for (i in 1:length(model)) {
    param = as.matrix(model[i])
    grad = as.matrix(gradients[i])
    momentum_state = as.matrix(optim_state[i])
    
    # Call your existing LARS implementation
    [param_upd, momentum_state_upd] = lars::update(
        param, grad, global_lr, momentum, momentum_state, weight_decay, trust_coeff)
    
    model_upd = append(model_upd, param_upd)
    optim_state_upd = append(optim_state_upd, momentum_state_upd)
  }
}

/*
 * Hyperparameter management based on LARS paper
 */

get_lars_hyperparams = function(int batch_size, boolean use_bn)
    return (double base_lr, int warmup_epochs, int total_epochs) {
  /*
   * Get recommended LARS hyperparameters based on batch size.
   * Based on Table 3 from the LARS paper.
   */
  
  if (use_bn) {
    # AlexNet-BN (better scaling properties)
    if (batch_size <= 512) {
      base_lr = 0.02
      warmup_epochs = 5
      total_epochs = 100
    } else if (batch_size <= 4096) {
      base_lr = 0.02  # Will be scaled to ~0.32 for 4K batch
      warmup_epochs = 5
      total_epochs = 100
    } else if (batch_size <= 8192) {
      base_lr = 0.02  # Will be scaled to ~0.64 for 8K batch
      warmup_epochs = 5
      total_epochs = 100
    } else if (batch_size <= 16384) {
      base_lr = 0.02  # Will be scaled to ~1.28 for 16K batch
      warmup_epochs = 5
      total_epochs = 100
    } else {  # 32K and above
      base_lr = 0.02  # Will be scaled to ~2.56 for 32K batch
      warmup_epochs = 5
      total_epochs = 200  # Need more epochs for very large batch
    }
  } else {
    # Regular AlexNet (limited scaling)
    if (batch_size <= 512) {
      base_lr = 0.01
      warmup_epochs = 2
      total_epochs = 100
    } else if (batch_size <= 4096) {
      base_lr = 0.01  # Will be scaled proportionally
      warmup_epochs = 2
      total_epochs = 100
    } else {
      # Regular AlexNet doesn't scale well beyond 4K
      print("Warning: Regular AlexNet (without BN) doesn't scale well beyond batch size 4K")
      base_lr = 0.01
      warmup_epochs = 2
      total_epochs = 100
    }
  }
}

/*
 * Training and evaluation utilities
 */

compute_loss = function(matrix[double] predictions, matrix[double] targets, list[unknown] model, double weight_decay)
    return (double loss) {
  /*
   * Compute cross-entropy loss with L2 regularization.
   */
  data_loss = cross_entropy_loss::forward(predictions, targets)
  reg_loss = 0
  for (i in seq(1, length(model), 2)) {  # Only weights, skip biases
    W = as.matrix(model[i])
    reg_loss = reg_loss + l2_reg::forward(W, 1)
  }
  loss = data_loss + weight_decay * reg_loss
}

compute_accuracy = function(matrix[double] predictions, matrix[double] targets)
    return (double accuracy) {
  /*
   * Compute classification accuracy.
   */
  pred_labels = rowIndexMax(predictions)
  true_labels = rowIndexMax(targets)
  accuracy = mean(pred_labels == true_labels)
}

evaluate = function(matrix[double] X, matrix[double] Y, int C, int Hin, int Win,
                    list[unknown] model, int batch_size)
    return (double loss, double accuracy) {
  /*
   * Evaluate model on a dataset.
   */
  N = nrow(X)
  total_loss = 0
  total_acc = 0
  num_batches = ceil(N / batch_size)
  
  for (i in 1:num_batches) {
    beg = ((i-1) * batch_size) %% N + 1
    end = min(N, beg + batch_size - 1)
    X_batch = X[beg:end,]
    Y_batch = Y[beg:end,]
    
    [predictions, cached_out] = forward(X_batch, C, Hin, Win, model, "test", 0.0)
    batch_loss = compute_loss(predictions, Y_batch, model, 0.0)
    batch_acc = compute_accuracy(predictions, Y_batch)
    
    total_loss = total_loss + batch_loss
    total_acc = total_acc + batch_acc
  }
  
  loss = total_loss / num_batches
  accuracy = total_acc / num_batches
}

evaluate_with_bn = function(matrix[double] X, matrix[double] Y, int C, int Hin, int Win,
                           list[unknown] model, int batch_size)
    return (double loss, double accuracy) {
  /*
   * Evaluate AlexNet-BN model on a dataset.
   */
  N = nrow(X)
  total_loss = 0
  total_acc = 0
  num_batches = ceil(N / batch_size)
  
  for (i in 1:num_batches) {
    beg = ((i-1) * batch_size) %% N + 1
    end = min(N, beg + batch_size - 1)
    X_batch = X[beg:end,]
    Y_batch = Y[beg:end,]
    
    [predictions, cached_out, emas] = forward_with_bn(X_batch, C, Hin, Win, model, "test", 0.0)
    batch_loss = compute_loss(predictions, Y_batch, model, 0.0)
    batch_acc = compute_accuracy(predictions, Y_batch)
    
    total_loss = total_loss + batch_loss
    total_acc = total_acc + batch_acc
  }
  
  loss = total_loss / num_batches
  accuracy = total_acc / num_batches
}