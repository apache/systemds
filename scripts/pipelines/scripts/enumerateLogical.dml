#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------
# Generate the logical pipelines using basic evolutionary algorithm, 
# population -> logical Pipeline, chromosome -> physical pipeline, gene -> hp
# input :
# 1. Dataset X
# 2. population, different logical seed pipelines format = [number of operators, op1, op2, op3 ..., opn]
# 3. number of iterations
# 4. pipLength, length of pipeline, number of operator in each pipeline
# 5. meta data list i.e., schema, mask, fdmask
# 6. target list i.e, target application, cv value etc.
# 7. primitives, physical operator list
# 8. param, physical operator hyperparameters
# 9. num_inst value, number of physical instances for each logical to be executed
# 10. num_exec, how many times each physical pipeline should be executed
# 11. n_pop, children created in each generation
# output: best logical pipeline and evaluation time in ms

# idea is to get the initial set of logical pipelines, as population, then get the num_inst physical pipelines foreach
# logical pipeline in population. Then execute these physical pipelines num_exec time were in each execution a random
# set of hyperparameters is used to execute operators. 
# The compute a score vector by storing the best score foreach logical pipeline in population. Sort the pipelines by
# score and take n_pop pipelines as parents for generating new population from the selected pipelines take a pair in
# each iteration as parent and generate a pair of children by doing crossover and mutation.
# There are total 3 transformation that will be performed to create a new chromosomes (children)
#   1. crossover to create children by adding n operation from p1 to p2 and vice versa. 
#   2. mutation to swap two operations in the children based on a mutation rate, swap is randomly based on mutationRatio.
#   3. removal to remove n operations from a child
# These new children will be the population in next iteration.
# Repeat the process max_iter time. Converge in between if the best_score of previous generation is better then
# best_score of new generation.


source("scripts/builtin/bandit.dml") as bandit;

enumerateLogical = function(Matrix[Double] X, Matrix[Double] y, Matrix[Double] Xtest, Matrix[Double] ytest,
  Frame[Unknown] cat, Frame[Unknown] population, Integer max_iter=10, List[Unknown] metaList, 
  String evaluationFunc, Matrix[Double] evalFunHp, Frame[Unknown] primitives, Frame[Unknown] param,
  Integer num_inst, Boolean cv=FALSE, Boolean cvk=3, Boolean verbose, List[Unknown] ctx=list(prefix="----"))
return (Frame[Unknown] bestLg, Double pre_best)
{

  num_exec = 1
  prefix = as.scalar(ctx["prefix"]);  
  bestLg = as.frame("")
  best_score = 0.0
  pre_best = 0.0
  iter = 1

  while(as.scalar(population[1, 1]) > 0 & iter < max_iter)
  {
    print(prefix+" EnumLP iteration "+iter+"/"+as.integer(max_iter)+":" );
    physicalPipList = list();
    logicalPipList = list();
    
    # get the physical instances from logical ones
    # unrolled by physical pipelines
    max_confR = 0
    max_confC = 0
    start = 1; 
    end = 0;
    for(i in 1:nrow(population)) { 
      lv = as.integer(as.scalar(population[i, 1])) + 1
      lp = population[i, 2:lv]
      pconf = bandit::get_physical_configurations(lp, 0, primitives)
      max_confR = ifelse(max_confR < nrow(pconf), nrow(pconf), max_confR)
      max_confC = ifelse(max_confC < ncol(pconf), ncol(pconf), max_confC)
      physicalPipList = append(physicalPipList, pconf);
      logicalPipList = append(logicalPipList, lp);

    }
    # print("pipeline Frame: "+toString(pipelineFrame))
    # # # execute the physical pipelines
    scores = matrix(0, rows=nrow(population) * max_confR, cols=2)
    start = 1; 
    end = 0;
    pipelineFrame = frame(0, rows=length(physicalPipList) * max_confR, cols=max_confC)
    parfor(i in 1:length(physicalPipList), check=0) {
      lp2 = as.frame(logicalPipList[i,])
      pp2 = as.frame(physicalPipList[i,])
      # # append configuration keys for extracting the pipeline later on
      id = seq(1, nrow(pp2))
      idpp = cbind(as.frame(id), pp2)
      # # execute the physical instances and store the minimum scores, each pipeline is executed num_exec times
      [outPip, outHp, feaFrameOuter] = bandit::run_with_hyperparam(lp2, idpp, num_exec, X, y, Xtest, ytest, metaList,
        evaluationFunc, evalFunHp, param, as.frame(""), cv, cvk, TRUE)
      # # sort the configurations groupwise
      end = end + nrow(outPip)
      scores[start:end, 1] = outPip[, 1]
      scores[start:end, 2] = matrix(i, rows=nrow(outPip), cols=1)
      start = end + 1
    }

    # # select parents and best score
    selected = order(target = scores[, 1], by = 1, decreasing=TRUE, index.return=TRUE)
    idxR = as.scalar(selected[1,1])
    best_score = as.scalar(scores[idxR, 1])
    converged =  pre_best >= best_score
    print("best score: "+best_score)
    print("pre score: "+pre_best)
    if(converged & (iter > 1)) {
      print(prefix+"EnumLP: converged after "+iter+" iteration(s)")
      print(prefix+"EnumLP: best score " + pre_best)
      print(prefix+"EnumLP: best pipeline " + toString(bestLg))
    }
    else {
      pre_best = best_score
      bestLg = as.frame(logicalPipList[as.scalar(scores[idxR, 2])])
      print("best logical: "+toString(bestLg))
    }
    pipLength = 10
    # # # if new best is not better than pre_best then no need od generating new population
    children = frame(0, rows=ceil(nrow(population)/2), cols=pipLength)
    i = 1
    while(i <= ceil(nrow(population)/2) & ncol(population) < pipLength - 1) {
      idxR = as.scalar(selected[i,1])
      top = as.frame(logicalPipList[as.scalar(scores[idxR, 2])])
      length_top = ncol(top)
      # generate children from crossover
      c1 = addition(top, cat, 1) #i%%(pipLength-1)

      # # # append length of pipeline and pipeline in frame
      children[i, 1] = ncol(c1)
      children[i, 2:(ncol(c1) + 1)] = c1
      
      i = i + 1
    }
    population = children
    iter  = iter + 1
  }
  if(pre_best < best_score) {
    print(prefix+" EnumLP did not converge after "+max_iter+" iterations")  
  }
}


addition = function(Frame[Unknown] top, Frame[Unknown] allOps, Integer addCount)
return (Frame [Unknown] child)
{
  for(i in 1:addCount)
  {
    c = as.scalar(sample(ncol(allOps), 1))
    place_to_add = as.scalar(sample(ncol(top)+2, 1))
    if(place_to_add == 1)
      child = cbind(allOps[1, c], top)
    else if(place_to_add >= ncol(top))
      child = cbind(top, allOps[1, c])
    else
    {
      start = top[, 1:place_to_add-1]
      end = top[, place_to_add+1:ncol(top)]
      child = cbind(cbind(start, allOps[1, c]), end)
    }
    top = child
  }
  hasDummy = map(child, "x -> x.equals(\"DUMMY\")")
  hasDummy = as.matrix(hasDummy == frame("true", rows=1, cols=ncol(hasDummy)))
  if(sum(hasDummy) > 0 & as.scalar(hasDummy[1, ncol(hasDummy)]) != 1)
  {
    # place the dummycode in last
    idx = as.scalar(removeEmpty(target = hasDummy*t(seq(1, ncol(hasDummy))), margin = "cols"))
    tmp = child[1, idx]
    child[1, idx] = child[1, ncol(child)]
    child[1, ncol(child)] = tmp
  }
}

