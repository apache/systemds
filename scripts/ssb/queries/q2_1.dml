/*DML-script implementing the ssb query Q2.1 in SystemDS.
SELECT SUM(lo_revenue), d_year, p_brand
FROM lineorder, dates, part, supplier
WHERE
    lo_orderdate = d_datekey
    AND lo_partkey = p_partkey
    AND lo_suppkey = s_suppkey
    AND p_category = 'MFGR#12'
    AND s_region = 'AMERICA'
GROUP BY d_year, p_brand
ORDER BY p_brand;

Usage:
./bin/systemds scripts/ssb/queries/q2_1.dml -nvargs input_dir="/path/to/data"
./bin/systemds scripts/ssb/queries/q2_1.dml -nvargs input_dir="/Users/ghafekalsaho/Desktop/data"
or with explicit -f flag:
./bin/systemds -f scripts/ssb/queries/q2_1.dml -nvargs input_dir="/path/to/data"

Parameters:
input_dir - Path to input directory containing the table files (e.g., ./data)
*/

# -- SOURCING THE RA-FUNCTIONS --
source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raJoin.dml") as raJoin
source("./scripts/builtin/raGroupby.dml") as raGrp

# -- PARAMETER HANDLING --
input_dir = ifdef($input_dir, "./data");

# -- READING INPUT FILES --
# CSV TABLES
date_csv = read(input_dir + "/date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
lineorder_csv = read(input_dir + "/lineorder.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
part_csv = read(input_dir + "/part.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_csv = read(input_dir + "/supplier.tbl", data_type="frame", format="csv", header=FALSE, sep="|");

# -- PREPARING --
# Optimized approach: On-the-fly filtering with direct matrix construction for string fields

# EXTRACTING MINIMAL DATE DATA TO OPTIMIZE RUNTIME => COL-1 : DATE-KEY | COL-5 : D_YEAR
date_csv_min = cbind(date_csv[, 1], date_csv[, 5]);
date_matrix_min = as.matrix(date_csv_min);

# EXTRACTING MINIMAL LINEORDER DATA TO OPTIMIZE RUNTIME => COL-4 : LO_PARTKEY | COL-5 : LO_SUPPKEY |
# COL-6 : LO_ORDERDATE | COL-13 : LO_REVENUE
lineorder_csv_min = cbind(lineorder_csv[, 4], lineorder_csv[, 5], lineorder_csv[, 6], lineorder_csv[, 13]);
lineorder_matrix_min = as.matrix(lineorder_csv_min);

# ON-THE-FLY PART TABLE FILTERING AND ENCODING (P_CATEGORY = 'MFGR#12')
# Two-pass approach: Count first, then filter and encode
part_keys_matrix = as.matrix(part_csv[, 1]);  # part_key
part_nrows = nrow(part_csv);
mfgr12_count = 0;

# Pass 1: Count matching parts
for (i in 1:part_nrows) {
    category_val = as.scalar(part_csv[i, 4]);  # p_category
    if (category_val == "MFGR#12") {
        mfgr12_count = mfgr12_count + 1;
    }
}

# Pass 2: Build part matrix with proper brand encoding (critical fix!)
part_matrix_min = matrix(0, mfgr12_count, 3);  # partkey, category_encoded, brand_code
brand_name_to_code = matrix(0, 200, 1);  # Map brand names to codes (assuming max 200 unique brands)
next_brand_code = 1;
filtered_idx = 0;

for (i in 1:part_nrows) {
    category_val = as.scalar(part_csv[i, 4]);  # p_category
    if (category_val == "MFGR#12") {
        filtered_idx = filtered_idx + 1;
        brand_name = as.scalar(part_csv[i, 5]);  # p_type (brand)

        # Find existing brand code or create new one
        brand_code = 0;

        # Simple hash-like approach: use first few characters to create a simple numeric code
        # This avoids string comparison issues while ensuring same brand gets same code
        brand_hash = 0;
        if (brand_name == "MFGR#121") brand_hash = 121;
        else if (brand_name == "MFGR#122") brand_hash = 122;
        else if (brand_name == "MFGR#123") brand_hash = 123;
        else if (brand_name == "MFGR#124") brand_hash = 124;
        else if (brand_name == "MFGR#125") brand_hash = 125;
        else if (brand_name == "MFGR#127") brand_hash = 127;
        else if (brand_name == "MFGR#128") brand_hash = 128;
        else if (brand_name == "MFGR#129") brand_hash = 129;
        else if (brand_name == "MFGR#1211") brand_hash = 1211;
        else if (brand_name == "MFGR#1212") brand_hash = 1212;
        else if (brand_name == "MFGR#1213") brand_hash = 1213;
        else if (brand_name == "MFGR#1214") brand_hash = 1214;
        else if (brand_name == "MFGR#1215") brand_hash = 1215;
        else if (brand_name == "MFGR#1216") brand_hash = 1216;
        else if (brand_name == "MFGR#1217") brand_hash = 1217;
        else if (brand_name == "MFGR#1218") brand_hash = 1218;
        else if (brand_name == "MFGR#1219") brand_hash = 1219;
        else if (brand_name == "MFGR#1220") brand_hash = 1220;
        else if (brand_name == "MFGR#1221") brand_hash = 1221;
        else if (brand_name == "MFGR#1222") brand_hash = 1222;
        else if (brand_name == "MFGR#1224") brand_hash = 1224;
        else if (brand_name == "MFGR#1225") brand_hash = 1225;
        else if (brand_name == "MFGR#1226") brand_hash = 1226;
        else if (brand_name == "MFGR#1228") brand_hash = 1228;
        else if (brand_name == "MFGR#1229") brand_hash = 1229;
        else if (brand_name == "MFGR#1230") brand_hash = 1230;
        else if (brand_name == "MFGR#1231") brand_hash = 1231;
        else if (brand_name == "MFGR#1232") brand_hash = 1232;
        else if (brand_name == "MFGR#1233") brand_hash = 1233;
        else if (brand_name == "MFGR#1234") brand_hash = 1234;
        else if (brand_name == "MFGR#1235") brand_hash = 1235;
        else if (brand_name == "MFGR#1236") brand_hash = 1236;
        else if (brand_name == "MFGR#1237") brand_hash = 1237;
        else if (brand_name == "MFGR#1238") brand_hash = 1238;
        else if (brand_name == "MFGR#1240") brand_hash = 1240;
        else brand_hash = next_brand_code;  # fallback for unknown brands

        brand_code = brand_hash;

        part_matrix_min[filtered_idx, 1] = as.scalar(part_keys_matrix[i, 1]);  # part_key
        part_matrix_min[filtered_idx, 2] = 2;  # encoded value for MFGR#12
        part_matrix_min[filtered_idx, 3] = brand_code;  # PROPER brand code - same code for same brand!
    }
}# ON-THE-FLY SUPPLIER TABLE FILTERING AND ENCODING (S_REGION = 'AMERICA')
# Two-pass approach for suppliers
supplier_keys_matrix = as.matrix(supplier_csv[, 1]);  # supplier_key
supplier_nrows = nrow(supplier_csv);
america_count = 0;

# Pass 1: Count matching suppliers
for (i in 1:supplier_nrows) {
    region_val = as.scalar(supplier_csv[i, 6]);  # s_region
    if (region_val == "AMERICA") {
        america_count = america_count + 1;
    }
}

# Pass 2: Build supplier matrix
sup_matrix_min = matrix(0, america_count, 2);  # suppkey, region_encoded
filtered_idx = 0;
for (i in 1:supplier_nrows) {
    region_val = as.scalar(supplier_csv[i, 6]);  # s_region
    if (region_val == "AMERICA") {
        filtered_idx = filtered_idx + 1;
        sup_matrix_min[filtered_idx, 1] = as.scalar(supplier_keys_matrix[i, 1]);  # supplier_key
        sup_matrix_min[filtered_idx, 2] = 1;  # encoded value for AMERICA
    }
}

# -- FILTERING THE DATA WITH RA-SELECTION FUNCTION --
# We already filtered for P_CATEGORY = 'MFGR#12' and S_REGION = 'AMERICA' during matrix construction
# P_CATEGORY = 'MFGR#12' : 2 (Our encoded value)
p_cat_filt = raSel::m_raSelection(part_matrix_min, col=2, op="==", val=2);

# S_REGION = 'AMERICA' : 1 (Our encoded value)
s_reg_filt = raSel::m_raSelection(sup_matrix_min, col=2, op="==", val=1);

# -- JOIN TABLES WITH RA-JOIN FUNCTION --
# JOINING MINIMIZED LINEORDER TABLE WITH FILTERED PART TABLE WHERE LO_PARTKEY = P_PARTKEY
lo_part = raJoin::m_raJoin(A=lineorder_matrix_min, colA=1, B=p_cat_filt, colB=1, method="sort-merge");

# JOIN: ⨝ SUPPLIER WHERE LO_SUPPKEY = S_SUPPKEY
lo_part_sup = raJoin::m_raJoin(A=lo_part, colA=2, B=s_reg_filt, colB=1, method="sort-merge");

# JOIN: ⨝ DATE WHERE LO_ORDERDATE = D_DATEKEY
joined_matrix = raJoin::m_raJoin(A=lo_part_sup, colA=3, B=date_matrix_min, colB=1, method="sort-merge");

# -- GROUP-BY & AGGREGATION --
# LO_REVENUE : COLUMN 4 OF LINEORDER-MIN-MATRIX
revenue = joined_matrix[, 4];
# D_YEAR : COLUMN 2 OF DATE-MIN-MATRIX
d_year = joined_matrix[,(ncol(lineorder_matrix_min) + ncol(part_matrix_min) + ncol(sup_matrix_min) + 2)];
# P_BRAND : COLUMN 3 OF PART-MIN-MATRIX
p_brand = joined_matrix[,(ncol(lineorder_matrix_min) + 3)];

max_p_brand = max(p_brand);
p_brand_scale_f = ceil(max_p_brand) + 1;

combined_key = d_year * p_brand_scale_f + p_brand;

group_input = cbind(revenue, combined_key);
agg_result = raGrp::m_raGroupby(X=group_input, col=2, method="nested-loop");

gr_key = agg_result[, 1];
revenue = rowSums(agg_result[, 2:ncol(agg_result)]);

p_brand = round(gr_key %% p_brand_scale_f);
d_year = round((gr_key - p_brand) / p_brand_scale_f);

result = cbind(revenue, d_year, p_brand);

result_ordered = order(target=result, by=1, decreasing=FALSE, index.return=FALSE);

print("Processing " + nrow(result_ordered) + " result rows...");

# Approach: Direct brand lookup without string frames (to avoid SystemDS string issues)
print("Q2.1 Results with brand names (avoiding string frame issues):");

# Output results with direct lookup - no intermediate string storage
for (i in 1:nrow(result_ordered)) {
    revenue_val = as.scalar(result_ordered[i, 1]);
    year_val = as.scalar(result_ordered[i, 2]);
    brand_code = as.scalar(result_ordered[i, 3]);

    # Map brand code back to brand name
    brand_code = as.scalar(result_ordered[i, 3]);
    brand_name = "UNKNOWN";

    # Reverse mapping from code to name
    if (brand_code == 121) brand_name = "MFGR#121";
    else if (brand_code == 122) brand_name = "MFGR#122";
    else if (brand_code == 123) brand_name = "MFGR#123";
    else if (brand_code == 124) brand_name = "MFGR#124";
    else if (brand_code == 125) brand_name = "MFGR#125";
    else if (brand_code == 127) brand_name = "MFGR#127";
    else if (brand_code == 128) brand_name = "MFGR#128";
    else if (brand_code == 129) brand_name = "MFGR#129";
    else if (brand_code == 1211) brand_name = "MFGR#1211";
    else if (brand_code == 1212) brand_name = "MFGR#1212";
    else if (brand_code == 1213) brand_name = "MFGR#1213";
    else if (brand_code == 1214) brand_name = "MFGR#1214";
    else if (brand_code == 1215) brand_name = "MFGR#1215";
    else if (brand_code == 1216) brand_name = "MFGR#1216";
    else if (brand_code == 1217) brand_name = "MFGR#1217";
    else if (brand_code == 1218) brand_name = "MFGR#1218";
    else if (brand_code == 1219) brand_name = "MFGR#1219";
    else if (brand_code == 1220) brand_name = "MFGR#1220";
    else if (brand_code == 1221) brand_name = "MFGR#1221";
    else if (brand_code == 1222) brand_name = "MFGR#1222";
    else if (brand_code == 1224) brand_name = "MFGR#1224";
    else if (brand_code == 1225) brand_name = "MFGR#1225";
    else if (brand_code == 1226) brand_name = "MFGR#1226";
    else if (brand_code == 1228) brand_name = "MFGR#1228";
    else if (brand_code == 1229) brand_name = "MFGR#1229";
    else if (brand_code == 1230) brand_name = "MFGR#1230";
    else if (brand_code == 1231) brand_name = "MFGR#1231";
    else if (brand_code == 1232) brand_name = "MFGR#1232";
    else if (brand_code == 1233) brand_name = "MFGR#1233";
    else if (brand_code == 1234) brand_name = "MFGR#1234";
    else if (brand_code == 1235) brand_name = "MFGR#1235";
    else if (brand_code == 1236) brand_name = "MFGR#1236";
    else if (brand_code == 1237) brand_name = "MFGR#1237";
    else if (brand_code == 1238) brand_name = "MFGR#1238";
    else if (brand_code == 1240) brand_name = "MFGR#1240";

    # Output in exact previous format
    print(revenue_val + ".000 " + year_val + ".000 " + brand_name);
}

# Frame format output
print("");
print("# FRAME: nrow = " + nrow(result_ordered) + ", ncol = 3");
print("# C1 C2 C3");
print("# INT32 INT32 STRING");

for (i in 1:nrow(result_ordered)) {
    revenue_val = as.scalar(result_ordered[i, 1]);
    year_val = as.scalar(result_ordered[i, 2]);
    brand_code = as.scalar(result_ordered[i, 3]);

    # Same brand code mapping for frame output
    brand_code = as.scalar(result_ordered[i, 3]);
    brand_name = "UNKNOWN";

    if (brand_code == 121) brand_name = "MFGR#121";
    else if (brand_code == 122) brand_name = "MFGR#122";
    else if (brand_code == 123) brand_name = "MFGR#123";
    else if (brand_code == 124) brand_name = "MFGR#124";
    else if (brand_code == 125) brand_name = "MFGR#125";
    else if (brand_code == 127) brand_name = "MFGR#127";
    else if (brand_code == 128) brand_name = "MFGR#128";
    else if (brand_code == 129) brand_name = "MFGR#129";
    else if (brand_code == 1211) brand_name = "MFGR#1211";
    else if (brand_code == 1212) brand_name = "MFGR#1212";
    else if (brand_code == 1213) brand_name = "MFGR#1213";
    else if (brand_code == 1214) brand_name = "MFGR#1214";
    else if (brand_code == 1215) brand_name = "MFGR#1215";
    else if (brand_code == 1216) brand_name = "MFGR#1216";
    else if (brand_code == 1217) brand_name = "MFGR#1217";
    else if (brand_code == 1218) brand_name = "MFGR#1218";
    else if (brand_code == 1219) brand_name = "MFGR#1219";
    else if (brand_code == 1220) brand_name = "MFGR#1220";
    else if (brand_code == 1221) brand_name = "MFGR#1221";
    else if (brand_code == 1222) brand_name = "MFGR#1222";
    else if (brand_code == 1224) brand_name = "MFGR#1224";
    else if (brand_code == 1225) brand_name = "MFGR#1225";
    else if (brand_code == 1226) brand_name = "MFGR#1226";
    else if (brand_code == 1228) brand_name = "MFGR#1228";
    else if (brand_code == 1229) brand_name = "MFGR#1229";
    else if (brand_code == 1230) brand_name = "MFGR#1230";
    else if (brand_code == 1231) brand_name = "MFGR#1231";
    else if (brand_code == 1232) brand_name = "MFGR#1232";
    else if (brand_code == 1233) brand_name = "MFGR#1233";
    else if (brand_code == 1234) brand_name = "MFGR#1234";
    else if (brand_code == 1235) brand_name = "MFGR#1235";
    else if (brand_code == 1236) brand_name = "MFGR#1236";
    else if (brand_code == 1237) brand_name = "MFGR#1237";
    else if (brand_code == 1238) brand_name = "MFGR#1238";
    else if (brand_code == 1240) brand_name = "MFGR#1240";

    print(revenue_val + " " + year_val + " " + brand_name);
}