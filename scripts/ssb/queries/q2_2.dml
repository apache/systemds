/* DML-script implementing the ssb query Q2.2 in SystemDS.
SELECT SUM(lo_revenue), d_year, p_brand
FROM lineorder, dates, part, supplier
WHERE
    lo_orderdate = d_datekey
    AND lo_partkey = p_partkey
    AND lo_suppkey = s_suppkey
    AND p_brand BETWEEN 'MFGR#2221' AND 'MFGR#2228'
    AND s_region = 'ASIA'
GROUP BY d_year, p_brand
ORDER BY d_year, p_brand;
*/

# -- SOURCING THE RA-FUNCTIONS --
source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raJoin.dml") as raJoin
source("./scripts/builtin/raGroupby.dml") as raGrp


# -- READING INPUT FILES --
# CSV TABLES
date_csv = read("./data/date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
lineorder_csv = read("./data/lineorder3.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
part_csv = read("./data/part.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_csv = read("./data/supplier.tbl", data_type="frame", format="csv", header=FALSE, sep="|");

# META DATA
part_meta = read("./data/meta/part_meta.csv", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_meta = read("./data/meta/supplier_meta.csv", data_type="frame", format="csv", header=FALSE, sep="|");


# -- PREPARING --
# EXTRACTING MINIMAL DATE DATA TO OPTIMIZE RUNTIME => COL-1 : DATE-KEY | COL-5 : D_YEAR
date_csv_min = cbind(date_csv[, 1], date_csv[, 5]);
date_matrix_min = as.matrix(date_csv_min);

# EXTRACTING MINIMAL LINEORDER DATA TO OPTIMIZE RUNTIME => COL-4 : LO_PARTKEY | COL-5 : LO_SUPPKEY |
# COL-6 : LO_ORDERDATE | COL-13 : LO_REVENUE
lineorder_csv_min = cbind(lineorder_csv[, 4], lineorder_csv[, 5], lineorder_csv[, 6], lineorder_csv[, 13]);
lineorder_matrix_min = as.matrix(lineorder_csv_min);

# EXTRACTING MINIMAL PART DATA TO OPTIMIZE RUNTIME => COL-1 : PART-KEY | COL-5 : P_BRAND
part_csv_min = cbind(part_csv[, 1], part_csv[, 5]);
part_enc_meta = cbind(part_meta[, 1], part_meta[, 5]);
part_enc_spec = "{ \"recode\": [\"C2\"] }";
part_matrix_min = transformapply(target=part_csv_min, meta=part_enc_meta, spec=part_enc_spec);
#print(part_matrix_min);
#part_jspec = read("../part.tfspec_recode.json", data_type="scalar", value_type="string");
#[part_matrix, part_meta] = transformencode(target=part_csv, spec=part_jspec);
#write(part_meta, "./data/meta/part_meta.csv", format="csv", sep="|");

# EXTRACTING MINIMAL SUPPLIERS DATA TO OPTIMIZE RUNTIME => COL-1 : SUP-KEY | COL-6 : S_REGION
sup_csv_min = cbind(supplier_csv[, 1], supplier_csv[, 6]);
sup_enc_meta = cbind(supplier_meta[, 1], supplier_meta[, 6]);
sup_enc_spec = "{ \"recode\": [\"C2\"] }";
sup_matrix_min = transformapply(target=sup_csv_min, meta=sup_enc_meta, spec=sup_enc_spec);
#print(sup_matrix_min);
#supplier_jspec = read("../supplier.tfspec_recode.json", data_type="scalar", value_type="string");
#[supplier_matrix, supplier_meta] = transformencode(target=supplier_csv, spec=supplier_jspec);
#write(supplier_meta, "./data/meta/supplier_meta.csv", format="csv", sep="|");


# -- FILTERING THE DATA WITH RA-SELECTION FUNCTION --
# P_BRAND BETWEEN 'MFGR#2221' AND 'MFGR#2228' (MAPPED VALUES IN PART_META.CSV)
vals = matrix("453 597 907 282 850 525 538 608", rows=8, cols=1);
p_brand_filt = matrix(0, rows=0, cols=ncol(part_matrix_min));

for (i in 1:nrow(vals)) {
    tmp_brand_filt = raSel::m_raSelection(part_matrix_min, col=2, op="==", val=as.scalar(vals[i, 1]));
    p_brand_filt = rbind(p_brand_filt, tmp_brand_filt);
}

# S_REGION = 'ASIA' : 5 (MAPPED VALUE IN SUPPLIER_META.CSV))
s_reg_filt = raSel::m_raSelection(sup_matrix_min, col=2, op="==", val=5);


# -- JOIN TABLES WITH RA-JOIN FUNCTION --
# JOINING MINIMIZED LINEORDER TABLE WITH FILTERED PART TABLE WHERE LO_PARTKEY = P_PARTKEY
lo_part = raJoin::m_raJoin(A=lineorder_matrix_min, colA=1, B=p_brand_filt, colB=1, method="sort-merge");

# JOIN: ⨝ SUPPLIER WHERE LO_SUPPKEY = S_SUPPKEY
lo_part_sup = raJoin::m_raJoin(A=lo_part, colA=2, B=s_reg_filt, colB=1, method="sort-merge");

# JOIN: ⨝ DATE WHERE LO_ORDERDATE = D_DATEKEY
joined_matrix = raJoin::m_raJoin(A=lo_part_sup, colA=3, B=date_matrix_min, colB=1, method="sort-merge");
#print(nrow(joined_matrix));


# -- GROUP-BY & AGGREGATION --
# LO_REVENUE : COLUMN 4 OF LINEORDER-MIN-MATRIX
revenue = joined_matrix[, 4];
# D_YEAR : COLUMN 2 OF DATE-MIN-MATRIX
d_year = joined_matrix[,(ncol(lineorder_matrix_min) + ncol(part_matrix_min) + ncol(sup_matrix_min) + 2)];
# P_BRAND : COLUMN 2 OF PART-MIN-MATRIX
p_brand = joined_matrix[,(ncol(lineorder_matrix_min) + 2)];

max_p_brand = max(p_brand);
p_brand_scale_f = ceil(max_p_brand) + 1;

combined_key = d_year * p_brand_scale_f + p_brand;

group_input = cbind(revenue, combined_key);
agg_result = raGrp::m_raGroupby(X=group_input, col=2, method="nested-loop");

gr_key = agg_result[, 1];
revenue = rowSums(agg_result[, 2:ncol(agg_result)]);

p_brand = round(gr_key %% p_brand_scale_f);
d_year = round((gr_key - p_brand) / p_brand_scale_f);

result = cbind(revenue, d_year, p_brand);

result_ordered = order(target=result, by=3, decreasing=FALSE, index.return=FALSE); # 3 : P_BRAND
result_ordered = order(target=result_ordered, by=2, decreasing=FALSE, index.return=FALSE); # D_YEAR
print(result_ordered)


# -- DECODING P_BRAND --
part_dec_meta = part_meta[, 5];
part_dec_spec = "{ \"recode\": [\"C1\"] }";
p_brand_dec = transformdecode(target=result_ordered[, 3], spec=part_dec_spec, meta=part_dec_meta);

result_decoded = cbind(as.frame(result_ordered[, 1]), as.frame(result_ordered[, 2]), p_brand_dec);

print(result_decoded);
#print("Q2.2 finished");
