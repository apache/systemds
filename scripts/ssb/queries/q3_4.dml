/* DML-script implementing the ssb query Q3.3 in SystemDS.
**input_dir="/scripts/ssb/data"

##TO DO
TO CHECK ON EMPTY TABLES with nrows else out of bounds statements. 
Expecially for q3_2, q3_3, q3_4. 
* Run with docker:
docker run -it --rm -v $PWD:/scripts/ apache/systemds:nightly -f /scripts/queries/q3_2.dml -nvargs input_dir="/scripts/data/"

SELECT
    c_city,
    s_city,
    d_year,
    SUM(lo_revenue) AS REVENUE
FROM customer, lineorder, supplier, date --dates
WHERE
    lo_custkey = c_custkey
    AND lo_suppkey = s_suppkey
    AND lo_orderdate = d_datekey
    AND (
        c_city = 'UNITED KI1'
        OR c_city = 'UNITED KI5'
    )
    AND (
        s_city = 'UNITED KI1'
        OR s_city = 'UNITED KI5'
    )
    AND d_yearmonth = 'Dec1997'
GROUP BY c_city, s_city, d_year
ORDER BY d_year ASC, REVENUE DESC;

*Please run the original SQL query (eg. in Postgres) 
to verify the correctness of DML version.
-> First tests: Works on the dataset with scale factor 0.1.
-> Sorting does not work.

*Based on older implementations.
https://github.com/ghafek/systemds/blob/feature/ssb-benchmark/scripts/ssb/queries/q1_1.dml
*Especially:
https://github.com/ghafek/systemds/blob/feature/ssb-benchmark/scripts/ssb/queries/q4_3.dml
In comparison to older version the join method was changed
from sort-merge to hash2 to improve the performance.

Input parameters:
input_dir - Path to input directory containing the table files (e.g., ./data)
*/

# Call ra-modules with ra-functions.
source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raJoin.dml") as raJoin
source("./scripts/builtin/raGroupby.dml") as raGrp

# Set input parameters.
input_dir = ifdef($input_dir, "./data");
print("Loading tables from directory: " + input_dir);

# Read and load input CSV files.  
lineorder_csv = read(input_dir + "/lineorder.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
cust_csv = read(input_dir + "/customer.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
date_csv = read(input_dir + "/date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
supp_csv = read(input_dir + "/supplier.tbl", data_type="frame", format="csv", header=FALSE, sep="|");

general_spec = "{ \"ids\": false, \"recode\": [\"C1\"] }";

# -- Data preparation --

# Extract only the necessary columns from tables.
# Extracted: COL-3 | COL-5 | COL-6 | COL-13
# => LO_CUSTKEY | LO_SUPPKEY | LO_ORDERDATE | LO_REVENUE
lineorder_csv_min = cbind(lineorder_csv[, 3], lineorder_csv[, 5], lineorder_csv[, 6], lineorder_csv[, 13]);
lineorder_matrix_min = as.matrix(lineorder_csv_min);

# -- Filter tables over string values.

# Extracted: COL-1 | COL-5 | COL-7
# D_DATEKEY | D_YEAR | D_YEARMONTH
# (only need D_DATEKEY & D_YEAR, filter by D_YEARMONTH string)
# Build filtered DATE table (D_YEARMONTH = 'Dec1997')
d_filt_keys = matrix(0, rows=0, cols=1);
d_filt_year = matrix(0, rows=0, cols=1);
for (i in 1:nrow(date_csv)) {
    if (as.scalar(date_csv[i,7]) == "Dec1997") {
        key_val = as.double(as.scalar(date_csv[i,1]));
        year_val = as.double(as.scalar(date_csv[i,5]));
        d_filt_keys = rbind(d_filt_keys, matrix(key_val, rows=1, cols=1));
        d_filt_year = rbind(d_filt_year, matrix(year_val, rows=1, cols=1));
    }
}
if (nrow(d_filt_keys) == 0) {
    d_filt_keys = matrix(0, rows=1, cols=1);
    d_filt_year = matrix(0, rows=1, cols=1);
}
d_filt = cbind(d_filt_keys, d_filt_year);

# Prepare SUPPLIER table on-the-fly encodings
# Extracted: COL-1 | COL-4
# S_SUPPKEY | S_CITY
# (only need S_CITY encoding, filter by S_CITY string itself)
[supp_city_enc_f, supp_city_meta] = transformencode(target=supp_csv[,4], spec=general_spec);

# Build filtered SUPPLIER table (S_CITY = 'UNITED KI1' OR S_CITY = 'UNITED KI5')
supp_filt_keys = matrix(0, rows=0, cols=1);
supp_filt_city = matrix(0, rows=0, cols=1);
for (i in 1:nrow(supp_csv)) {
    s_elem = as.scalar(supp_csv[i,4])
    if (s_elem == "UNITED KI1" | s_elem == "UNITED KI5") {
        key_val = as.double(as.scalar(supp_csv[i,1]));
        city_code = as.double(as.scalar(supp_city_enc_f[i,1]));
        supp_filt_keys = rbind(supp_filt_keys, matrix(key_val, rows=1, cols=1));
        supp_filt_city = rbind(supp_filt_city, matrix(city_code, rows=1, cols=1));
    }
}
if (nrow(supp_filt_keys) == 0) {
    supp_filt_keys = matrix(0, rows=1, cols=1);
    supp_filt_city = matrix(0, rows=1, cols=1);
}
supp_filt = cbind(supp_filt_keys, supp_filt_city);

# Prepare CUSTOMER table on-the-fly encodings
# Extracted: COL-1 | COL-4
# C_CUSTKEY | C_CITY
# (only need C_CITY encoding, filter by C_CITY string itself)
[cust_city_enc_f, cust_city_meta] = transformencode(target=cust_csv[,4], spec=general_spec);

# Build filtered CUSTOMER table (C_CITY = 'UNITED KI1' OR C_CITY = 'UNITED KI5')
cust_filt_keys = matrix(0, rows=0, cols=1);
cust_filt_city = matrix(0, rows=0, cols=1);
for (i in 1:nrow(cust_csv)) {
    c_elem = as.scalar(cust_csv[i,4])
    if (c_elem == "UNITED KI1" | c_elem == "UNITED KI5") {
        key_val = as.double(as.scalar(cust_csv[i,1]));
        city_code = as.double(as.scalar(cust_city_enc_f[i,1]));
        cust_filt_keys = rbind(cust_filt_keys, matrix(key_val, rows=1, cols=1));
        cust_filt_city = rbind(cust_filt_city, matrix(city_code, rows=1, cols=1));
    }
}
if (nrow(cust_filt_keys) == 0) {
    cust_filt_keys = matrix(0, rows=1, cols=1);
    cust_filt_city = matrix(0, rows=1, cols=1);
}
cust_filt = cbind(cust_filt_keys,cust_filt_city);

#print("LO,DATE,CUST,SUPP")
#print(toString(lineorder_matrix_min[1,]))
#print(toString(date_matrix_min[1,]))
#print(toString(cust_filt[1,]))
#print(toString(supp_filt[1,]))

# -- JOIN TABLES WITH RA-JOIN FUNCTION --

# Join LINEORDER table with CUST, SUPPLIER, DATE tables (star schema)
# Join order does matter! 
# WHERE LO_CUSTKEY = C_CUSTKEY
lo_cust = raJoin::m_raJoin(A=cust_filt, colA=1, B=lineorder_matrix_min, colB=1, method="hash2");
# WHERE LO_SUPPKEY = S_SUPPKEY

lo_cust_supp = raJoin::m_raJoin(A=supp_filt, colA=1, B=lo_cust, colB=4, method="hash2");
# WHERE LO_ORDERDATE = D_DATEKEY
# (D_DATEKEY | D_YEAR) | (S_SUPPKEY | S_CITY | C_CUSTKEY | C_CITY |
# LO_CUSTKEY | LO_SUPPKEY | LO_ORDERDATE | LO_REVENUE)

joined_matrix = raJoin::m_raJoin(A=d_filt, colA=1, B=lo_cust_supp, colB=7, method="hash2");
#print(toString(joined_matrix[1,]));

if(nrow(joined_matrix[,1]) == 0){
    print("c_city | s_city | d_year | REVENUE");
    print("The result table has 0 rows.");
}
else{

# -- Group-By and Aggregation (SUM)--

# Group-By
d_year = joined_matrix[,2];
s_city = joined_matrix[,4];
c_city = joined_matrix[,6];
revenue = joined_matrix[,10];

# CALCULATING COMBINATION KEY WITH PRIORITY:1 C_CITY, 2 S_CITY, D_YEAR
max_c_city= max(c_city);
max_s_city= max(s_city);
max_d_year = max(d_year);

c_city_scale_f = ceil(max_c_city) + 1;
s_city_scale_f = ceil(max_s_city) + 1;
d_year_scale_f = ceil(max_d_year) + 1;

combined_key = c_city * s_city_scale_f * d_year_scale_f + s_city * d_year_scale_f + d_year;

group_input = cbind(revenue, combined_key)

agg_result = raGrp::m_raGroupby(X=group_input, col=2, method="nested-loop");
#print(toString(agg_result[1,]));

# Aggregation (SUM)
key = agg_result[, 1];
revenue = rowSums(agg_result[, 2:ncol(agg_result)]);

# EXTRACTING C_CITY, S_CITY, D_YEAR
c_city = round(floor(key / (s_city_scale_f * d_year_scale_f)));
s_city = round(floor((key %% (s_city_scale_f * d_year_scale_f)) / d_year_scale_f));
d_year = round(key %% d_year_scale_f);

result = cbind(c_city, s_city, d_year, revenue, key)

# -- Sorting -- -- Sorting int columns works, but strings do not.
# ORDER BY D_YEAR ASC, REVENUE DESC
result_ordered = order(target=result, by=4, decreasing=TRUE, index.return=FALSE);
result_ordered = order(target=result_ordered, by=3, decreasing=FALSE, index.return=FALSE);

c_city_dec = transformdecode(target=result_ordered[,1], spec=general_spec, meta=cust_city_meta);
s_city_dec = transformdecode(target=result_ordered[,2], spec=general_spec, meta=supp_city_meta);

res = cbind(c_city_dec, s_city_dec, as.frame(result_ordered[,3]), as.frame(result_ordered[,4])) ;

# Print result
print("c_city | s_city | d_year | REVENUE")
print(res)

print("\nQ3.3 finished.\n");
}