# DML-script implementing the ssb query Q3.4 in SystemDS.

# -- SOURCING THE RA-FUNCTIONS --
source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raJoin.dml") as raJoin
source("./scripts/builtin/raGroupby.dml") as raGrp


# -- READING INPUT FILES --
# CSV TABLES
date_csv = read("./data/date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
lineorder_csv = read("./data/lineorder3.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
#part_csv = read("./data/part.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_csv = read("./data/supplier.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
customer_csv = read("./data/customer.tbl", data_type="frame", format="csv", header=FALSE, sep="|");

# META DATA
date_meta = read("./data/meta/date_meta.csv", data_type="frame", format="csv", header=FALSE, sep="|");
customer_meta = read("./data/meta/customer_meta.csv", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_meta = read("./data/meta/supplier_meta.csv", data_type="frame", format="csv", header=FALSE, sep="|");


# -- PREPARING --
# EXTRACTING MINIMAL DATE DATA TO OPTIMIZE RUNTIME => COL-1 : DATE-KEY | COL-5 : D_YEAR |
# COL-7 : D_YEARMONTH
date_csv_min = cbind(date_csv[, 1], date_csv[, 5], date_csv[, 7]);
date_enc_meta = cbind(date_meta[, 1], date_meta[, 5], date_meta[, 7]);
date_enc_spec = "{ \"recode\": [\"C3\"] }";
date_matrix_min = transformapply(target=date_csv_min, meta=date_enc_meta, spec=date_enc_spec);

# EXTRACTING MINIMAL LINEORDER DATA TO OPTIMIZE RUNTIME => COL-3 : LO_CUSTKEY | COL-4 : LO_PARTKEY |
# COL-5 : LO_SUPPKEY | COL-6 : LO_ORDERDATE | COL-13 : LO_REVENUE
lineorder_csv_min = cbind(lineorder_csv[, 3], lineorder_csv[, 4], lineorder_csv[, 5], lineorder_csv[, 6], lineorder_csv[, 13]);
lineorder_matrix_min = as.matrix(lineorder_csv_min);

# EXTRACTING MINIMAL CUSTOMER DATA TO OPTIMIZE RUNTIME => COL-1 : CUSTOMER-KEY | COL-4 : C_CITY
cust_csv_min = cbind(customer_csv[, 1], customer_csv[, 4]);
cust_enc_meta = cbind(customer_meta[, 1], customer_meta[, 4]);
cust_enc_spec = "{ \"recode\": [\"C2\"] }";
cust_matrix_min = transformapply(target=cust_csv_min, meta=cust_enc_meta, spec=cust_enc_spec);

# EXTRACTING MINIMAL SUPPLIERS DATA TO OPTIMIZE RUNTIME => COL-1 : SUP-KEY | COL-4 : S_CITY
sup_csv_min = cbind(supplier_csv[, 1], supplier_csv[, 4]);
sup_enc_meta = cbind(supplier_meta[, 1], supplier_meta[, 4]);
sup_enc_spec = "{ \"recode\": [\"C2\"] }";
sup_matrix_min = transformapply(target=sup_csv_min, meta=sup_enc_meta, spec=sup_enc_spec);


# -- FILTERING THE DATA WITH RA-SELECTION FUNCTION --
# C_CITY = 'UNITED KI1' : 207 OR  'UNITED KI5' : 15 (MAPPED VALUES IN CUSTOMER_META.CSV)
c_city_filt_1 = raSel::m_raSelection(cust_matrix_min, col=2, op="==", val=207);
c_city_filt_2 = raSel::m_raSelection(cust_matrix_min, col=2, op="==", val=15);
c_city_filt = rbind(c_city_filt_1, c_city_filt_2);

# S_CITY = 'UNITED KI1' : 60 OR  'UNITED KI5' : 153 (MAPPED VALUES IN SUPLLIER_META.CSV)
s_city_filt_1 = raSel::m_raSelection(sup_matrix_min, col=2, op="==", val=60);
s_city_filt_2 = raSel::m_raSelection(sup_matrix_min, col=2, op="==", val=153);
s_city_filt = rbind(s_city_filt_1, s_city_filt_2);

# D_YEARMONTH = 'Dec1997' : 72 (MAPPED VALUE IN DATE_META.CSV)
d_year_filt = raSel::m_raSelection(date_matrix_min, col=3, op=">=", val=72);


# -- JOIN TABLES WITH RA-JOIN FUNCTION --
# JOINING MINIMIZED LINEORDER TABLE WITH FILTERED CUSTOMER TABLE WHERE LO_CUSTKEY = C_CUSTKEY
lo_cust = raJoin::m_raJoin(A=lineorder_matrix_min, colA=1, B=c_city_filt, colB=1, method="sort-merge");

# JOIN: ⨝ SUPPLIER WHERE LO_SUPPKEY = S_SUPPKEY
lo_cust_sup = raJoin::m_raJoin(A=lo_cust, colA=3, B=s_city_filt, colB=1, method="sort-merge");

# JOIN: ⨝ DATE WHERE LO_ORDERDATE = D_DATEKEY
joined_matrix = raJoin::m_raJoin(A=lo_cust_sup, colA=4, B=d_year_filt, colB=1, method="sort-merge");
#print(nrow(joined_matrix));


# -- GROUP-BY & AGGREGATION --
# LO_REVENUE : COLUMN 5 OF LINEORDER-MIN-MATRIX
revenue = joined_matrix[, 5];
# D_YEAR : COLUMN 2 OF DATE-MIN-MATRIX
d_year = joined_matrix[,(ncol(lineorder_matrix_min) + ncol(cust_matrix_min) + ncol(sup_matrix_min) + 2)];
# C_CITY : COLUMN 2 OF CUST-MIN-MATRIX
c_city = joined_matrix[,(ncol(lineorder_matrix_min) + 2)];
# S_CITY : COLUMN 2 OF CUST-MIN-MATRIX
s_city = joined_matrix[,(ncol(lineorder_matrix_min) + ncol(cust_matrix_min) + 2)];

# CALCULATING COMBINATION KEY WITH PRIORITY: C_CITY, S_CITY & D_YEAR
max_c_city = max(c_city);
max_s_city = max(s_city);
max_d_year = max(d_year);

c_city_scale_f = ceil(max_c_city) + 1;
s_city_scale_f = ceil(max_s_city) + 1;
d_year_scale_f = ceil(max_d_year) + 1;

combined_key = c_city * s_city_scale_f * d_year_scale_f + s_city * d_year_scale_f + d_year;

group_input = cbind(revenue, combined_key);
agg_result = raGrp::m_raGroupby(X=group_input, col=2, method="nested-loop");

key = agg_result[, 1];
revenue = rowSums(agg_result[, 2:ncol(agg_result)]);

# EXTRACTING C_CITY, S_CITY & D_YEAR
d_year = round(key %% d_year_scale_f);
c_city = round(floor(key / (s_city_scale_f * d_year_scale_f)));
s_city = round((floor(key / d_year_scale_f)) %% s_city_scale_f);

result = cbind(c_city, s_city, d_year, revenue);


# -- SORTING --
# PRIORITY 1 D_YEAR (ASC), 2 REVENUE (DESC)
result_ordered = order(target=result, by=4, decreasing=TRUE, index.return=FALSE);
result_ordered = order(target=result_ordered, by=3, decreasing=FALSE, index.return=FALSE);


# -- DECODING C_CITY & S_CITY --
cust_dec_meta = customer_meta[, 4];
cust_dec_spec = "{ \"recode\": [\"C1\"] }";

sup_dec_meta = supplier_meta[, 4];
sup_dec_spec = "{ \"recode\": [\"C1\"] }";

c_city_dec = transformdecode(target=result_ordered[, 1], spec=cust_dec_spec, meta=cust_dec_meta);
s_city_dec = transformdecode(target=result_ordered[, 2], spec=sup_dec_spec, meta=sup_dec_meta);
res = cbind(c_city_dec, s_city_dec, as.frame(result_ordered[, 3]), as.frame(result_ordered[, 4]));

print(res);
#print("Q3.4 finished");
