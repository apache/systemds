source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raGroupby.dml") as raGrp
source("./scripts/builtin/raJoin.dml") as raJoin

# READ INPUTS
date = read("../date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
data_jspec = read("../date.tfspec_recode.json", data_type="scalar", value_type="string");
[date_matrix, date_meta] = transformencode(target=date, spec=data_jspec);
print("date loaded and transformed.");

lineorder = read("../lineorder3.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
lineorder_jspec = read("../lineorder.tfspec_recode.json", data_type="scalar", value_type="string");
[lineorder_matrix, lineorder_meta] = transformencode(target=lineorder, spec=lineorder_jspec);
print("lineorder loaded and transformed.");

part = read("../part.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
part_jspec = read("../part.tfspec_recode.json", data_type="scalar", value_type="string");
[part_matrix, part_meta] = transformencode(target= part, spec=part_jspec);
print("part loaded and transformed.");

customer = read("../customer.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
customer_jspec = read("../customer.tfspec_recode.json", data_type="scalar", value_type="string");
[customer_matrix, customer_meta] = transformencode(target=customer, spec=customer_jspec);
print("customer loaded and transformed.");

supplier = read("../supplier.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
supplier_jspec = read("../supplier.tfspec_recode.json", data_type="scalar", value_type="string");
[supplier_matrix, supplier_meta] = transformencode(target=supplier, spec=supplier_jspec);
print("supplier loaded and transformed.");


#date = 0;
#lineorder = 0;
#part = 0;
#customer = 0;
#supplier = 0;


# FILTERS
#  c_region = 'AMERICA' (3)
#cust_meta_col = customer_meta[, 6];
#print(cust_meta_col);
cust_filt = raSel::m_raSelection(customer_matrix, col=6, op="==", val=3);
print(nrow(cust_filt));

# s_region = 'AMERICA' (1)
#sup_meta_col = supplier_meta[, 6];
#print(sup_meta_col);
sup_filt = raSel::m_raSelection(supplier_matrix, col=6, op="==", val=1);
print(nrow(sup_filt));

# p_mfgr = 'MFGR#1' (1) OR 'MFGR#2' (4)
#part_meta_col = part_meta[, 3];
#write(part_meta_col, "B.tbl");
part_filt_1 = raSel::m_raSelection(part_matrix, col=3, op="==", val=1);
part_filt_2 = raSel::m_raSelection(part_matrix, col=3, op="==", val=4);
part_filt = rbind(part_filt_1, part_filt_2);
print(nrow(part_filt));

# d_year = 1997 OR 1998
date_filt_97 = raSel::m_raSelection(date_matrix, col=5, op="==", val=1997);
date_filt_98 = raSel::m_raSelection(date_matrix, col=5, op="==", val=1998);
date_filt = rbind(date_filt_97, date_filt_98);
print(nrow(date_filt));

print("Selection done.");


# JOIN: lineorder ⨝ date
lo_date = raJoin::m_raJoin(A=lineorder_matrix, colA=6, B=date_filt, colB=1, method="sort-merge");
print("lo-date joined");

# JOIN: ⨝ part
lo_date_part = raJoin::m_raJoin(A=lo_date, colA=4, B=part_filt, colB=1, method="sort-merge");
print("lo-date-part joined");

# JOIN: ⨝ customer
lo_date_part_cust = raJoin::m_raJoin(A=lo_date_part, colA=3, B=cust_filt, colB=1, method="sort-merge");
print("lo-date-part-customer joined");

# JOIN: ⨝ supplier
joined_matrix = raJoin::m_raJoin(A=lo_date_part_cust, colA=5, B=sup_filt, colB=1, method="sort-merge");
print("lo-date-part-customer-supplier joined");

print("All tables joined.");

#print(nrow(joined_matrix));


# PREPARE GROUPBY
revenue = joined_matrix[,13];
supplycost = joined_matrix[,14];
profit = revenue - supplycost;
d_year = joined_matrix[,(ncol(lineorder_matrix) + 5)];
s_nation = joined_matrix[,(ncol(lineorder_matrix) + ncol(date_matrix) + ncol(part_matrix) + ncol(customer_matrix) + 5)];
p_category = joined_matrix[,(ncol(lineorder_matrix) + ncol(date_matrix) + 4)];


# Skalierungsfaktoren (max + 1) für s_nation und p_category
max_s_nation = max(s_nation);
max_p_category = max(p_category);
max_d_year = max(d_year);

s_nation_scale_f = ceil(max_s_nation) + 1;
p_category_scale_f = ceil(max_p_category) + 1;
d_year_scale_f = ceil(max_d_year) + 1;

# Kombinierter Schlüssel mit Sortierpriorität d_year, s_nation, p_category
# Das ist das klassische Prinzip, eine Kombination von Gruppier-/Sortierschlüsseln in einen einzigen Schlüssel umzuwandeln.
combined_key = d_year * s_nation_scale_f * p_category_scale_f + s_nation * p_category_scale_f + p_category;

group_input = cbind(profit, combined_key);
agg_result = raGrp::m_raGroupby(X=group_input, col=2, method="nested-loop");


key = agg_result[, 1];
summed_result = rowSums(agg_result[, 2:ncol(agg_result)]);

d_year = round(floor(key / (s_nation_scale_f * p_category_scale_f)));
s_nation = round(floor((key %% (s_nation_scale_f * p_category_scale_f)) / p_category_scale_f));
p_category = round(key %% p_category_scale_f);

result = cbind(d_year, s_nation, p_category, summed_result, key);


# EINMALIGE Sortierung nach combined_key
result = order(target=result, by=5, decreasing=FALSE, index.return=FALSE);
print(result);

# Decoding
cust_jspec2 = read("../part2.tfspec_recode.json", data_type="scalar", value_type="string");
s_meta_col = supplier_meta[, 5];
p_meta_col = part_meta[, 4];

s_nat_dec = transformdecode(target=result[, 2], spec=cust_jspec2, meta=s_meta_col);
p_cat_dec = transformdecode(target=result[, 3], spec=cust_jspec2, meta=p_meta_col);

res = cbind(as.frame(result[, 1]), s_nat_dec, p_cat_dec, as.frame(result[, 4]));

print(res);
print("Q4.2 finished");
