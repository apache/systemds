#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------



# run the script staging/learnedSampling/1_Data_Model_Prep.dml to prepare the model
# also, store meatadata M from transformencode to use partitions

source("../shapley-permutation-opt.dml") as shapleyPermutation
source("../shapley-permutation.dml") as shapleyPermutationLegacy
source("../shapley-utils.dml") as shapleyUtils

X_bg = read("../data/Adult_X.csv")
y = read("../data/Adult_y.csv")
B = read("../data/Adult_W.csv")

# you set the total number of permutations from the commandline using `-nvargs n_permutations=10`
n_permutations = ifdef($n_permutations, 10)
# you set the total number of integration_samples from the commandline using `-nvargs integration_samples=100`
integration_samples = ifdef($integration_samples, 10)
execution_policy = ifdef($execution_policy, "auto")
# you set the total number of rows from the commandline using `-nvargs rows_to_explain=10`
rows_to_explain = ifdef($rows_to_explain, 10)
# set remove_non_var
remove_non_var = ifdef($remove_non_var, 0)
# use partitions
use_partitions = ifdef($use_partitions, 0)
if (use_partitions == 1){
  metadata = read("../data/Adult_meta.csv")
  metadata = metadata[,2:(ncol(metadata)-1)]
  partitions=shapleyUtils::meatadataToPartitions(metadata=metadata)
} else {
  partitions = as.matrix(-1)
}

print("Computing shapley values for "+rows_to_explain+" rows with "+n_permutations+" permutatitons, "+integration_samples+" samples to marginalise masked features.")
#select instances to compute shapley values for
x = X_bg[2:rows_to_explain+1,]

#print("Samples: \n"+toString(x))

#compute shapley values
if(execution_policy != 'legacy-iterative'){

  [S, expected] = shapleyPermutation::shapley_permutation_explainer(
    model_function="shap_multiLogRegPredict_custom",
    model_args=list(B=B),
    x=x,
    X_bg=X_bg,
    n_permutations=n_permutations,
    integration_samples=integration_samples,
    desired_max_batch_size=-1,
    execution_policy=execution_policy,
    remove_non_var=remove_non_var,
    partitions=partitions,
    seed=-1,
    verbose=1
  )
} else {
  print("Using iterative legacy approach.")
  S = matrix(0, rows=nrow(x), cols=ncol(x))
  expected = matrix(0, rows=nrow(x), cols=1)
  parfor (i in 1:nrow(x), check=0){
    [phis, e] = shapleyPermutationLegacy::shapley_permutations(
      model_function="shap_multiLogRegPredict_custom",
      model_args=list(B=B),
      x=x[i],
      X_bg=X_bg,
      n_permutations=n_permutations,
      integration_samples=integration_samples,
      seed=-1,
      verbose=0
    )
    S[i] = phis
    expected[i] = e
  }
  expected = mean(expected)

}
print("Expected: "+toString(expected))
print("Resulting phis rowsum:\n"+toString(rowSums(S)))

#transpose it to make it fit the representation of values in the SHAP python package
S = t(S)
# write values to csv
write_to_file = ifdef($write_to_file, 1)
if( write_to_file == 1){
  print("Writing to file")
  write(S, "../data/Adult_shap-values_permutation_"+n_permutations+"perm_"+integration_samples+"samples.csv", format="csv")
}




# function to wrap multiLogRegPredict to make sure its outputs are compatible
shap_multiLogRegPredict_custom = function(Matrix[Double] X, Matrix[Double] B)
return( Matrix[Double] P){
  [M,yhat,acc] = multiLogRegPredict(X=X, B=B,Y=matrix(0,0,0), verbose=FALSE)
  P = M[,2]
}