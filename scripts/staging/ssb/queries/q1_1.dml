#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------



/* DML-script implementing the ssb query Q1.1 in SystemDS.
**input_dir="/scripts/ssb/data"

* Run with docker:
docker run -it --rm -v $PWD:/scripts/ apache/systemds:nightly -f /scripts/queries/q1_1.dml -nvargs input_dir="/scripts/data/"

SELECT SUM(lo_extendedprice * lo_discount) AS REVENUE
FROM lineorder, date
WHERE
    lo_orderdate = d_datekey
    AND d_year = 1993
    AND lo_discount BETWEEN 1 AND 3
    AND lo_quantity < 25;

*Please run the original SQL query (eg. in Postgres) 
to verify the correctness of DML version.
-> First tests: Works on the dataset with scale factor 0.1.

*Based on the older implementation.
https://github.com/ghafek/systemds/blob/feature/ssb-benchmark/scripts/ssb/queries/q1_1.dml
In comparison to older version the join method was changed
from sort-merge to hash2 to improve the performance.

Input parameters:
input_dir - Path to input directory containing the table files (e.g., ./data)
*/

# Call ra-modules with ra-functions.
source("./scripts/builtin/raSelection.dml") as raSel
source("./scripts/builtin/raJoin.dml") as raJoin

# Set input parameters.
input_dir = ifdef($input_dir, "./data");
print("Loading tables from directory: " + input_dir);

# Read and load input CSV files from date and lineorder.  
date_csv = read(input_dir + "/date.tbl", data_type="frame", format="csv", header=FALSE, sep="|");
lineorder_csv = read(input_dir + "/lineorder.tbl", data_type="frame", format="csv", header=FALSE, sep="|");

# General variables.
hasRows = 1; # If hasRows = 0, the result table is empty.

# -- Data preparation --

# Extract only the necessary columns from date and lineorder table.
# Extracted: COL-1 | COL-5
# => D_DATEKEY | D_YEAR
date_csv_min = cbind(date_csv[, 1], date_csv[, 5]);
date_matrix_min = as.matrix(date_csv_min);

# Extracted: COL-6 | COL-9 | COL-10 | COL-12
# => LO_ORDERDATE | LO_QUANTITY | LO_EXTPRICE | LO_DISCOUNT
lineorder_csv_min = cbind(lineorder_csv[, 6], lineorder_csv[, 9], lineorder_csv[, 10], lineorder_csv[, 12]);
lineorder_matrix_min = as.matrix(lineorder_csv_min);

# -- Filter the data with RA-SELECTION function.

# D_YEAR = 1993
d_year_filt = raSel::m_raSelection(date_matrix_min, col=2, op="==", val=1993);
if( as.scalar(d_year_filt[1,1]) == 0){
    hasRows = 0;
}
# LO_QUANTITY < 25
if(hasRows){
    lo_filt = raSel::m_raSelection(lineorder_matrix_min, col=2, op="<", val=25);
    if( as.scalar(lo_filt[1,1]) == 0){
        hasRows = 0;
    }
}
# LO_DISCOUNT BETWEEN 1 AND 3
if(hasRows){
    lo_filt = raSel::m_raSelection(lo_filt, col=4, op=">=", val=1);
    lo_filt = raSel::m_raSelection(lo_filt, col=4, op="<=", val=3);
    if( as.scalar(lo_filt[1,1]) == 0){
        hasRows = 0;
    }
    else{
        # Minimize LO TABLE
        # => LO_ORDERDATE | LO_EXTPRICE | LO_DISCOUNT
        lo_filt = cbind(lo_filt[, 1], lo_filt[, 3], lo_filt[, 4]);
    }
}

# -- Join --
# Join LINEORDER and DATE tables with RA-JOIN function
joined_matrix = matrix(0, rows=0, cols=1);
# WHERE LO_ORDERDATE = D_DATEKEY
# => (D-KEY | D-YEAR) | (LO_ORDERDATE | LO_EXTPRICE | LO_DISCOUNT)
if(hasRows){
    joined_matrix = raJoin::m_raJoin(A=d_year_filt, colA=1, B=lo_filt, colB=1, method="hash2");
    if(nrow(joined_matrix[,1]) == 0){
            hasRows = 0;
        }
}
# Print the first row.
#print(toString(joined_matrix[1,]))

# -- Aggregation (SUM)--

if(hasRows){
    # SUM(lo_extendedprice * lo_discount) AS REVENUE
    # Use the joined_matrix with LO_EXTPRICE (COL-4), LO_DISCOUNT (COL-5)
    lo_extprice = joined_matrix[, 4];		
    lo_disc = joined_matrix[, 5];			
    revenue = sum(lo_extprice * lo_disc);

    print("REVENUE")
    print(as.integer(revenue));

    print("\nQ1.1 finished.\n");
}
else{
    print("REVENUE")
    print("The result table has 0 rows.")
    print("\nQ1.1 finished.\n");
}

