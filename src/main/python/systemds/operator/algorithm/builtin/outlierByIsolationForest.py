# -------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# -------------------------------------------------------------

# Autogenerated By   : src/main/python/generator/generator.py
# Autogenerated From : scripts/builtin/outlierByIsolationForest.dml

from typing import Dict, Iterable

from systemds.operator import OperationNode, Matrix, Frame, List, MultiReturn, Scalar
from systemds.utils.consts import VALID_INPUT_TYPES


def outlierByIsolationForest(X: Matrix,
                             n_trees: int,
                             subsampling_size: int,
                             **kwargs: Dict[str, VALID_INPUT_TYPES]):
    """
     Builtin function that implements anomaly detection via isolation forest as described in
     [Liu2008]:
       Liu, F. T., Ting, K. M., & Zhou, Z. H.
       (2008, December).
       Isolation forest.
       In 2008 eighth ieee international conference on data mining (pp. 413-422).
       IEEE.
    
     This function creates an iForest model for outlier detection.
    
     .. code-block:: python
    
       >>> import numpy as np
       >>> from systemds.context import SystemDSContext
       >>> from systemds.operator.algorithm import outlierByIsolationForest, outlierByIsolationForestApply
       >>> with SystemDSContext() as sds:
       ...     # Create training data: 20 points clustered near origin
       ...     X_train = sds.from_numpy(np.array([
       ...         [0.0, 0.0], [0.1, 0.1], [0.2, 0.2], [0.3, 0.3], [0.4, 0.4],
       ...         [0.5, 0.5], [0.6, 0.6], [0.7, 0.7], [0.8, 0.8], [0.9, 0.9],
       ...         [1.0, 1.0], [1.1, 1.1], [1.2, 1.2], [1.3, 1.3], [1.4, 1.4],
       ...         [1.5, 1.5], [1.6, 1.6], [1.7, 1.7], [1.8, 1.8], [1.9, 1.9]
       ...     ]))
       ...     model = outlierByIsolationForest(X_train, n_trees=100, subsampling_size=10, seed=42)
       ...     X_test = sds.from_numpy(np.array([[1.0, 1.0], [100.0, 100.0]]))
       ...     scores = outlierByIsolationForestApply(model, X_test).compute()
       ...     print(scores.shape)
       ...     print(scores[1, 0] > scores[0, 0])
       ...     print(scores[1, 0] > 0.5)
       (2, 1)
       True
       True
    
    
    
    
    :param X: Numerical feature matrix
    :param n_trees: Number of iTrees to build
    :param subsampling_size: Size of the subsample to build iTrees with
    :param seed: Seed for calls to `sample` and `rand`. -1 corresponds to a random seed
    :return: The trained iForest model to be used in outlierByIsolationForestApply.
        The model is represented as a list with two entries:
        Entry 'model' (Matrix[Double]) - The iForest Model in linearized form (see m_iForest)
        Entry 'subsampling_size' (Double) - The subsampling size used to build the model.
    """

    params_dict = {'X': X, 'n_trees': n_trees, 'subsampling_size': subsampling_size}
    params_dict.update(kwargs)
    return Matrix(X.sds_context,
        'outlierByIsolationForest',
        named_input_nodes=params_dict)
