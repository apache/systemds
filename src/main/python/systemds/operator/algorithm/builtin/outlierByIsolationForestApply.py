# -------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# -------------------------------------------------------------

# Autogenerated By   : src/main/python/generator/generator.py
# Autogenerated From : scripts/builtin/outlierByIsolationForestApply.dml

from typing import Dict, Iterable

from systemds.operator import OperationNode, Matrix, Frame, List, MultiReturn, Scalar
from systemds.utils.consts import VALID_INPUT_TYPES


def outlierByIsolationForestApply(iForestModel: List,
                                  X: Matrix):
    """
     Builtin function that calculates the anomaly score as described in [Liu2008]
     for a set of samples `X` based on an iForest model.
    
     [Liu2008]:
       Liu, F. T., Ting, K. M., & Zhou, Z. H.
       (2008, December).
       Isolation forest.
       In 2008 eighth ieee international conference on data mining (pp. 413-422).
       IEEE.
    
     .. code-block:: python
    
       >>> import numpy as np
       >>> from systemds.context import SystemDSContext
       >>> from systemds.operator.algorithm import outlierByIsolationForest, outlierByIsolationForestApply
       >>> with SystemDSContext() as sds:
       ...     # Create training data: 20 points clustered near origin
       ...     X_train = sds.from_numpy(np.array([
       ...         [0.0, 0.0], [0.1, 0.1], [0.2, 0.2], [0.3, 0.3], [0.4, 0.4],
       ...         [0.5, 0.5], [0.6, 0.6], [0.7, 0.7], [0.8, 0.8], [0.9, 0.9],
       ...         [1.0, 1.0], [1.1, 1.1], [1.2, 1.2], [1.3, 1.3], [1.4, 1.4],
       ...         [1.5, 1.5], [1.6, 1.6], [1.7, 1.7], [1.8, 1.8], [1.9, 1.9]
       ...     ]))
       ...     model = outlierByIsolationForest(X_train, n_trees=100, subsampling_size=10, seed=42)
       ...     X_test = sds.from_numpy(np.array([[1.0, 1.0], [100.0, 100.0]]))
       ...     scores = outlierByIsolationForestApply(model, X_test).compute()
       ...     print(scores.shape)
       ...     print(scores[1, 0] > scores[0, 0])
       ...     print(scores[1, 0] > 0.5)
       (2, 1)
       True
       True
    
    
    
    
    :param iForestModel: The trained iForest model as returned by outlierByIsolationForest
    :param X: Samples to calculate the anomaly score for
    :return: Column vector of anomaly scores corresponding to the samples in X.
        Samples with an anomaly score > 0.5 are generally considered to be outliers
    """

    params_dict = {'iForestModel': iForestModel, 'X': X}
    return Matrix(iForestModel.sds_context,
        'outlierByIsolationForestApply',
        named_input_nodes=params_dict)
