/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.sysml.test.gpu;

import java.util.Random;
import org.junit.Test;
import org.junit.Assert;
import org.apache.sysml.api.jmlc.Connection;
import org.apache.sysml.api.jmlc.PreparedScript;


public class JMLCTests extends GPUTests {

    static class ScriptContainer {
        String dml;
        String[] inputVarNames;
    }

    @Test
    public void testJMLC() {
        try {
            Connection conn = new Connection();

            int numMatrices = 10;
            int matrixNumRows = 100;
            int numScriptInvocations = 10;

            ScriptContainer SC = generateDMLScript(numMatrices);

            PreparedScript script = conn.prepareScript(
                    SC.dml, SC.inputVarNames, new String[] { "Z" }, true, true, 0);

            // execute the script without pinning input matrices between invocations
            executeDMLScript(script, numScriptInvocations, matrixNumRows, numMatrices, false);

            // execute the script while pinning input matrices between invocations
            executeDMLScript(script, numScriptInvocations, matrixNumRows, numMatrices, true);
        } catch (Exception e) {
            Assert.fail("An unexpected exception occurred: " + e.getMessage());
        }
    }

    // Generates a simple synthetic DML script which multiplies a sequence of square matrices.
    // I.e. Z = X %*% W1 %*% W2 %*% W3 ...
    // numMatrices determines the number of matrices in the sequences. The size of the matrices can be set
    // in executeDMLScript
    static ScriptContainer generateDMLScript(int numMatrices) {
        ScriptContainer SC = new ScriptContainer();
        String[] inputVarNames = new String[numMatrices + 1];
        inputVarNames[0] = "x";

        StringBuilder dml = new StringBuilder("x = read(\"/tmp/X.mtx\", rows=-1, cols=-1)\n");
        for (int ix=0; ix<numMatrices; ix++)
        {
            String name = "W" + ix;
            inputVarNames[ix+1] = name;
            dml.append(name + " = read(\"/tmp/" + name + ".mtx\", rows=-1, cols=-1)\n");
        }

        dml.append("Z = x %*% W0\n");
        for (int ix=1; ix<numMatrices; ix++)
        {
            dml.append("Z = Z %*% W" + ix + "\n");
        }

        dml.append("while (-1 > 1)\n    print(as.scalar(Z[1,1]))\n");

        SC.dml = dml.toString();
        SC.inputVarNames = inputVarNames;

        return SC;
    }

    // Executes a PreparedScript generated by generateDMLScript. The parameter n determines the
    // number of times the script is invoked. The parameter rows controls the shape of the matrices.
    // Set this parameter larger to use more memory. The parameter numMatrices must be set to the same value as
    // in generateDMLScript. The parameter pinWeights controls whether weight matrices should be
    // pinned in memory between script invocations.
    static void executeDMLScript(PreparedScript script, int n, int rows, int numMatrices, boolean pinWeights) {
        for (int ix=0; ix<numMatrices; ix++)
            script.setMatrix("W" + ix, randomMatrix(rows, rows, 0.0,1.0, 1.0), pinWeights);

        for (int ix=0; ix<n; ix++)
        {
            script.setMatrix("x", randomMatrix(rows, rows, 0.0, 1.0, 1.0), false);
            script.executeScript();
            if (!pinWeights)
                for (int iy=0; iy<numMatrices; iy++)
                    script.setMatrix(
                            "W" + iy, randomMatrix(rows, rows, 0.0,1.0, 1.0), false);
        }
    }

    static double[][] randomMatrix(
            int rows, int cols, double min, double max, double sparsity) {
        double[][] matrix = new double[rows][cols];
        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (random.nextDouble() > sparsity) {
                    continue;
                }
                matrix[i][j] = (random.nextDouble() * (max - min) + min);
            }
        }
        return matrix;
    }

}
