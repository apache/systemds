#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

#concats rows of a matrix n times at the end
concatMatrixRows = function (Matrix [Double] V, Integer N)
  return(Matrix [Double] V)
{
  tmp = V
  for(i in seq(1, N-1, 1)) {
    tmp = rbind(tmp, V)
  }
  V = tmp
}

computeVectors = function (Matrix [Double] codes, Matrix [Double] codebook)
  return(Matrix [Double] vectors)
{
  vectors = matrix(0, rows=nrow(codes), cols=ncol(codes)*ncol(codebook))
  parfor (i in 1:nrow(codes), check=0) {
    parfor (j in 1:ncol(codes), check=0) {
      vectors[i, 1 + (j-1)* ncol(codebook): j * ncol(codebook)] = codebook[as.scalar(codes[i, j])]
    }
  }
}

max = 1
min = -max
offset = max / 10

subvectors = $cols / $subvector_size
rows = $clusters * $vectors_per_cluster

if($test_case == "sub_cluster") {
  # Generate points by concatenating sub_points around sub_clusters
  offset_matrix = rand(rows=rows, cols=$cols, min=-offset, max=offset, pdf="uniform", seed=2)
  cluster_centers = rand(rows = $clusters, cols = $subvector_size, min=min, max=max, seed=2)
  vectors = matrix(cluster_centers, nrow(cluster_centers), ncol(cluster_centers))
  #todo is the permutation neccessary?
  #concat rows with a random row permutation of cluster_centers
  for(i in 1:subvectors-1)  {
    c_rows = $clusters
    perm = matrix(0, rows=c_rows, cols=c_rows)
    s = sample(c_rows, c_rows, FALSE)
    parfor(i in 1:c_rows, check=0) {
      idx = as.scalar(s[i])
      perm[i, idx] = 1
    }
    vectors = cbind(vectors, perm %*% cluster_centers)
  }
  #ensure correct number of vectors
  vectors = concatMatrixRows(vectors, $vectors_per_cluster)
  vectors = vectors + offset_matrix
}
else if ($test_case == "cluster") {
  # Generate points around clusters
  cluster_centers = rand(rows = $clusters, cols = $cols, min=min, max=max, pdf="uniform", seed=2)
  vectors = matrix(cluster_centers, nrow(cluster_centers), ncol(cluster_centers))
  #ensure correct number of vectors
  vectors = concatMatrixRows(vectors, $vectors_per_cluster)

  offset_matrix = rand(rows=rows, cols=$cols, min=-offset, max=offset, pdf="uniform", seed=2)
  vectors = vectors + offset_matrix
}
else {
  # Generate random points
  vectors = rand(rows = rows, cols = $cols, min=min, max=max, pdf=$test_case, seed=2)
}

[codebook, codes] = quantizeByCluster(vectors, $subvector_size, $k, $runs, $max_iter, $eps, $vectors_per_cluster, 2)
[k_codebook, k_codes] = kmeans(vectors, $k, $runs, $max_iter, $eps, FALSE, $vectors_per_cluster, 2)

#construct vectors from codes
pq_result = computeVectors(codes, codebook)
k_result = computeVectors(k_codes, k_codebook)

pq_distortion = colSums(rowSums((vectors - pq_result)^2)) / rows
k_distortion = colSums(rowSums((vectors - k_result)^2)) / rows

#print(toString(pq_distortion))
#print(toString(k_distortion))

write(codes, $codes)
write(codebook, $codebook)
write(pq_distortion, $pq_distortion)
write(k_distortion, $k_distortion)















